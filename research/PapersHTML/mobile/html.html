<!DOCTYPE HTML PUBLIC "-//IETF//DTD HTML 2.0//EN">
<!--Converted with LaTeX2HTML .95.3 (Nov 17 1995) by Nikos Drakos (nikos@cbl.leeds.ac.uk), CBLU, University of Leeds -->
<HTML>
<HEAD>
<TITLE>A Logic Programming Infrastructure for Internet Programming, Mobile Code and Agents</TITLE>
<meta name="description" value="No Title">
<meta name="keywords" value="html">
<meta name="resource-type" value="document">
<meta name="distribution" value="global">
<LINK REL=STYLESHEET HREF="html.css">
</HEAD>
<BODY bgcolor=white LANG="EN">
 
<center>
<h1>A Logic Programming Infrastructure for Internet Programming, Mobile Code and Agents. </h1>
</center><br><br>    
  

<P>
  <a href="http://clement.info.umoncton.ca/~tarau"><B>PAUL TARAU</B></a>, <br> 
  D&#233;partement d'Informatique, <br>
  Universit&#233; de Moncton, CANADA E1A-3E9 <br>
    E-mail: <EM>tarau@info.umoncton.ca</EM>. 
    <p>
  <a href="http://fas.sfu.ca/1/cs/people/Faculty/Dahl/index.html"><B>VERONICA DAHL</B></a>, <br>
    Logic and Functional Programming Group,<br>
    Department of Computing Sciences, Simon Fraser University, <br>
    E-mail: <EM>veronica}@cs.sfu.ca</EM>. 
    <p>   
   <a href="http://www.elis.rug.ac.be/ELISgroups/paris/staff/kdb.html"><B>KOEN DE BOSSCHERE</B></a>, <br>
    Vakgroep Elektronica en Informatiesystemen, <br>
    Universiteit Gent, E-mail: <EM>kdb@elis.rug.ac.be</EM>.
   

<P>
<H3 CLASS=ABSTRACT>Abstract:</H3>
<P CLASS=ABSTRACT><EM>We describe a set of programming patterns used for implementing a
scalable infrastructure which supports remote execution
mechanisms, mobile code and agents in a distributed logic programming
framework.
The particular focus of this paper is on the use of BinProlog's strong
metaprogramming abilities.  Some advanced logic programming constructs,
as intuitionistic implication and high-order <TT>call/N</TT>, cooperate with
encapsulated socket-level constructs for maximum configurability and
efficiency.  We show that strong metaprogramming is not a security
threat if used through a set of <EM>filtering interactors</EM> which
allow source level implementation of arbitrary security policies. 
Mobile code is implemented in a scalable way 
through a set of distributed client+server pairs
interconnected through a master server acting only as
an address exchange broker for peer-to-peer interactors.
We have thoroughly tested our programming patterns and design principles
through a realistic implementation in a widely
used, freely available Prolog system
(<TT>http://clement.info.umoncton.ca/BinProlog</TT>)
as well as with its Java peers built on top of
our unification enhanced Java based Linda implementation
(<TT>http://clement.info.umoncton.ca/LindaInteractor</TT>).
<EM>Keywords:
  mobile code, remote execution, metaprogramming, agents, Linda
  coordination, blackboard-based logic programming, Prolog, distributed
  programming, virtual worlds, scalable and
  secure Internet programming, Prolog/Java embedding
</EM>
</EM></P><P>
<H1><A NAME="SECTION00010000000000000000">Introduction</A></H1>
 <A NAME="intro">&#160;</A>
<P>
Although the Internet has been designed to survive nuclear war and its
underlying packet switching technology is intrinsically 
peer-to-peer, fault-tolerant and scalable,
successive higher level networking and programming layers have given
up (often too easily) these abilities.
Among the most annoying <EM>and</EM> at the same time the
most pragmatically well thought decisions dominating the world
of the Internet, at various programming  and application development layers:
<UL><LI> classical client/server architectures have given up scalability
for simplicity of programming and synchronization;
<LI> programming languages/operating systems have given up
powerful remote execution mechanisms for reasons ranging
from security concerns to
legacy single user/single process assumptions.
</UL>
<P>
In this paper, we will show how some standard and some non-standard
Logic Programming language tools can be used to elegantly recover 
the full potential of the Internet for building scalable, peer-to-peer,
programmable multi-user communities.  The virtual layer we will build
is based on a small set of very-high level programming constructs
making essential use of meta-programming, which is seen here as the
ability to view information either as code or as data, and
efficiently switch between these views, on demand. In particular, we
will show how powerful remote execution mechanisms, agents and mobile
code can be expressed in this framework.
<P>
With important resources at their disposal, operating
system/computer/network companies have found their own (often complex and
costly) ways to get back some of the original power, hidden under
various layers of software/hardware. 
Despite the existence
of practical solutions to some of these problems, no
unifying approach exists that can help clarify the
logical structure of future peer-to-peer, scalable virtual communities,
where the distinction between human and non-human agents will become less
and less obvious. This article proposes one such approach. We are also convinced that the power of the knowledge/processing component
of logic programming will 
help  efforts towards making
intelligent network/mobile agent programming more
effective.
<P>
We will describe our constructs as built on the top of the popular
Linda coordination framework, enhanced with unification improved pattern
matching, although our actual implementation is based on a more general
<EM>coordination logic</EM>. This allows negotiation of tuple removal as well
as of suspension between 
user intents at <EM>definition time</EM>, when an object is
stored on the (shared and synchronized) <EM>blackboard</EM>, as well
as at <EM>reference time</EM>, when it is retrieved associatively[<A HREF="html.html#TD96coord">20</A>].
<P>
Linda [<A HREF="html.html#linda89">5</A>] based frameworks like Multi-BinProlog [<A HREF="html.html#dbt95a">8</A>] offer a wide variety of <EM>blocking</EM> and <EM>non-blocking</EM> as well as
<EM>non-deterministic</EM> blackboard operations (backtracking through alternative
answers). For reasons of embeddability in multi-paradigm
environments and semantic simplicity we have decided
to drop non-determinism and return to a subset close to
the original Linda operators (combined with unification),
and simple client-server component
melted together into a scalable peer-to-peer
layer forming a `web of interconnected worlds'.
<P>
<TT>
<PRE><TT> 
<TT>out(X)</TT> 		 puts <TT>X</TT> on the server
<P>
<TT>in(X)</TT> 		  waits until it can take an object matching <TT>X</TT> from the server
<P>
<TT>all(X,Xs)</TT> 		 reads the list <TT>Xs</TT> matching <TT>X</TT> currently on the server
<P>
<TT>run(Goal)</TT> 		 starts a thread executing Goal
<P>
<TT>halt</TT> 		 stops current thread
<P>
</TT></PRE></TT>
<P>
The presence of the <TT>all/2</TT> collector compensates for
the lack of non-deterministic operations.
Note that the only blocking operation is <TT>in/1</TT>.
Notice that blocking <TT>rd/1</TT> is easily
emulated in terms of <TT>in/1</TT> and <TT>out/1</TT>,
while non-blocking <TT>rd/1</TT> is emulated with <TT>all/2</TT>.
<P>
<P><A NAME="332">&#160;</A><A NAME="linda">&#160;</A> <IMG WIDTH=289 HEIGHT=180 ALIGN=BOTTOM ALT="figure324" SRC="img1.gif"  > <BR>
<STRONG> 1:</STRONG> Basic Linda operations<BR>
<P><H1><A NAME="SECTION00020000000000000000">Simple Agents</A></H1>
 <A NAME="simple">&#160;</A>
<P>
A <EM>servant</EM> is one of the simplest possible <EM>agents</EM>:
<P>
<TT><PRE>servant(Who):-
  in(todo(Task)),
  secure(Task),
  run(Task),
  servant(Who).
</PRE></TT>
<P>
The <EM>servant</EM> is  started as a background thread
with <TT>run(servant(Name))</TT>. No `busy wait' is involved,
as the servant's thread
blocks until <TT>in(todo(Task))</TT>
succeeds.
<P>
In an `Internet chat' application, for instance,
<TT>whisper/2</TT>, defined as
<TT><PRE>whisper(To,Mes):-
  whoami(From),
  out(todo(mes_to(To,Mes,From))).
</PRE></TT>
<P>
unblocks the matching <TT>in(todo(mes_to(To,Mes,From)))</TT>
of a <EM>notifier servant</EM> which then outputs a message by
<TT>executing <TT>mes_to(To,Mes,From)</TT></TT>.
<P>
More generally, distributed event processing is implemented
by creating a `watching' agent for a given pattern.
<P>
Note the fundamental link between `event-processing' and the
more general Linda protocol: basically an <TT>out/1</TT> operation
can be seen as generating an event and adding it to the event queue,
while an <TT>in/1</TT> operation can be seen as servicing an event.
While usually event-loops switch on numeric or pseudo-numeric 
event constants in a rather rigid and non-compositional way,
Linda-based event dispatching is extensible by adding
new patterns. When (naturally)
restricted to ground patterns, efficient
indexing can be used with performance hits
unnoticeable in a network lag context.
Linda's <TT>out/blocking in</TT> combination can be
seen as automating the complex if-then-else logic of (distributed)
hierarchical message dispatching loops through
unification.
<P>
<EM>Remote processing</EM> as well as
simple security mechanisms are expressed easily, 
by creating a `command server' thread close to the following code:
<P>
<TT><PRE>% remote processing request
please(Who,What):-
  whoami(ForWho),
  out(please(Who,ForWho,What)).

% a remote command processor
command_server:-
  whoami(Me), % gets unique user identification information
  repeat,
    in(please(Me,ForWho,What)),
    ( friend_of(Me,ForWho)-&gt;call(What),fail % trusted friends
    ; errmes(intruder(remote_action_attempted),ForWho)
    ),
  fail.
</PRE></TT>
<P>
Clearly, <TT>command_server</TT> and <TT>notifier</TT>
threads can be seen as `behavior components' of a unique agent.
Moreover, they actually might cooperate in a synchronized way if each
<TT>please/2</TT> command would trigger a <TT>whisper/2</TT> action
to be serviced by a notifier later.
In this example security is based on allowing arbitrary
execution for trusted (i.e. known to <TT>friend_of/2</TT>) clients
of existing server-side code.
<P>
Note that by restricting <TT>command_server</TT> to execute only
sequences of acceptable known commands, on top of
code-as-data sent through <TT>out/1</TT> transactions,
arbitrary security mechanisms can be put in place at source
level. We will describe this in more detail  later.
<P>
<H1><A NAME="SECTION00030000000000000000">Towards a Web of Worlds</A></H1>
<P>
The MOO<A NAME="tex2html3" HREF="#163"><IMG ALIGN=BOTTOM ALT="gif" SRC="icons//foot_motif.gif" width="15" height="15"></A> inspired `Web of Worlds' metaphor [<A HREF="html.html#TDRB97chi">22</A>, <A HREF="html.html#lpnet96virtual">24</A>] 
as a set of Linda blackboards storing state information
on servers connected over the the Internet allows a simple and secure
remote execution mechanism through specialized <EM>server-side</EM> interpreters.
<P>
Our implementation is integrated in the
freely available BinProlog compiler,
starting with version 5.60.
To ensure interoperability between Windows 95/NT PCs and Unix machines
we have conservatively implemented a generic socket package with
operations specialized towards support for Linda operations
and remote execution. A master server on a `well-known' host/port
is used to exchange identification information among peers composed
of a client and a `multiplexing' server (Fig. <A HREF="html.html#master">1</A>)
<P><A NAME="344">&#160;</A><A NAME="master">&#160;</A> <IMG WIDTH=287 HEIGHT=181 ALIGN=BOTTOM ALT="figure336" SRC="img2.gif"  > <BR>
<STRONG> 1:</STRONG> A Web of Worlds<BR>
<P><H2><A NAME="SECTION00031000000000000000">Server side code</A></H2>
<P>
The code for our `generic' server, with 
various components which are overridden through the use of intuitionistic
implication to obtain customized special purpose servers at
user level, follows. Higher order <TT>call/N</TT> [<A HREF="html.html#mycroftpoli">16</A>], combined with intuitionistic assumptions,
are used to pass arbitrary <EM>interactors</EM> to this
generic server code.
<P>
<TT><PRE>run_server(Port,Fuel):-
  new_server(Port,NewServer),
  register_server(Port),
    server(NewServer)=&gt;&gt;server_loop(NewServer,Fuel),
  close_socket(NewServer).

server_loop(Server,Fuel):-
  for(I,1,Fuel),
    interact(Server),   
    assumed(server_done(Mes)),
  !.

interact(Server):-
  default_server_action(Interactor),
  ( call(Interactor,Server)-&gt;true % higher-order call to interactor
  ; \+ errmes(failed_interaction(Server),Interactor)
  ),
  !.
</PRE></TT>
<P>
Note the use of a specialized <EM>server-side</EM> interpreter
<TT>server_loop</TT>, configurable through  higher-order 
`question/answer' closures we have called <EM>interactors</EM>.
<P>
We have found out that the use of intuitionistic implications  
 (pioneered by
Miller's work [<A HREF="html.html#Miller89Mod">15</A>, <A HREF="html.html#Miller89Lex">14</A>, <A HREF="html.html#hodasiclp90">9</A>]) helps to overcome (to some extent) Prolog's lack
of object oriented programming facilities,
by allowing us to `inject' the right interactor into
the generic (and therefore reusable) interpreter.
BinProlog's <TT>=&gt;&gt;</TT> temporarily assumes a clause
in `<TT>asserta</TT>' order, i.e. at the beginning of the predicate.
The assumption is scoped to be only usable to prove its
right side goal and vanishes on backtracking.
We refer to [<A HREF="html.html#Tarau97BinProlog">19</A>, <A HREF="html.html#TDFasian96">21</A>, <A HREF="html.html#DT97AGNL">7</A>]
for more information on assumptions and their applications.
<P>
<H2><A NAME="SECTION00032000000000000000">Client side code</A></H2>
<P>
The following example shows how the same client-side code
is used for both for point-to-point and `broadcast' communication,
depending on a <TT>to_all(Pattern)</TT> assumption allowing
to select matching targets.
<P>
<TT><PRE>ask_server(Question,Answer):-
  assumed(to_all(ServerPattern)),!,
  all_servers(ServerPattern,Xs),
  ask_all_servers(Xs,Question),
  Answer=yes.
ask_server(Question,Answer):-
  ask_a_server(Question,Answer).
</PRE></TT>
<P>
Slightly more complex code (see file <TT>extra.pl</TT> in the
BinProlog distribution) also handles proxy forwarding
services transparently.
<P>
<H1><A NAME="SECTION00040000000000000000">Remote execution mechanisms</A></H1>
<P>
Implementation of arbitrary remote execution is easy
in a Linda + Prolog system due to Prolog's metaprogramming
abilities. No complex serialization or remote procedure/method call 
packages are needed. In BinProlog (starting with version 5.60)
code fetched lazily over
the network is cached in a local database and then
dynamically recompiled on the fly if usage statistics
indicate that it is not volatile and it is heavily used locally.
<P>
<TT><PRE>host(Other_machine)=&gt;remote_run(RemoteGoal).

host(Other_machine)=&gt;remote_run(Answer,RemoteGoal).
</PRE></TT>
<P>
allow remote predicate calls without/with returned answer
on the calling site.
<P>
<TT><PRE>host(Other_machine)=&gt;rsh(ShellCommand,CharListAnswer).

host(Other_machine)=&gt;rsh(ShellCommand).
</PRE></TT>
<P>
allows us to use BinProlog to remotely execute shell commands
on a remote machine and collect/print the answers at the
calling site<A NAME="tex2html4" HREF="#192"><IMG ALIGN=BOTTOM ALT="gif" SRC="icons//foot_motif.gif" width="15" height="15"></A>.
<P>
As an example, high performance file-transfer (actually known to be faster than
well-known <TT>http</TT> as <TT>ftp</TT> protocols) is implemented by orchestrating
Prolog based <TT>remote_run</TT> control operations, which are
used to trigger direct full speed transfers entirely left
to optimized C built-ins like <TT>sock2file/2</TT>:
<P>
<TT><PRE>fget(RemoteFile,LocalFile):-
   remote_run(RF,fopen(RemoteFile,'rb',RF)),
   fopen(LocalFile,'wb',LF),
   term_chars(to_sock(RF),Cmd),
   new_client(Socket),
     sock_write(Socket,Cmd),
     socket(Socket)=&gt;&gt;from_sock(LF,_),
     fclose(LF),
     sock_read(Socket,_),
   close_socket(Socket),
   remote_run(fclose(RF)).

from_sock(F,yes):-
   assumed(socket(S)),
   sock2file(S,F),!.
</PRE></TT>
<P>
Once the basic Linda protocol is in place, and Prolog terms
are sent through sockets, a command filtering server loop
simply listens and executes the set of `allowed' commands.
<P>
Despite Prolog's lack of object oriented features, we have implemented
code reuse with intuitionistic assumptions [<A HREF="html.html#TDFasian96">21</A>, <A HREF="html.html#DT97AGNL">7</A>].
<P>
For instance, to iterate over the set of servers forming
the receiving end of our `Web of Worlds', after retrieving
the list from a `master server' which constantly monitors
them making sure that the list reflects login/logout
information, we simply override <TT>host/1</TT> and <TT>port/1</TT> with
intuitionistic implication:
<P>
<TT><PRE>ask_all_servers(ListOfServers,Question):-
  member(server_id(_,H,P),ListOfServers),
  host(H)=&gt;&gt;port(P)=&gt;&gt;ask_a_server(Question,_),
  fail.
ask_all_servers(_,_).
</PRE></TT>
<P>
To specialize 
a generic server into either a master server or a
secure `chat-only' server which merges messages from BinProlog
users world-wide, we simply override the filtering step in the 
generic server's main interpreter loop.
<P>
<H2><A NAME="SECTION00041000000000000000">Unrestricted servers: full remote metaprogramming</A></H2>
<P>
On an Intranet of trusted users and computers, or in different
windows of an unconnected PC or workstation, a user might want 
to experiment with a server allowing arbitrary Prolog command
execution, i.e. full <EM>remote metaprogramming</EM>.
One can start a local remote predicate call server
with:
<P>
<TT><PRE>?-run_unrestricted_server.
</PRE></TT>
<P>
BinProlog's convention is that if the name returned by 
<TT>default_host/1</TT>
is different from <TT>localhost</TT> it assumes that the
user wants to get connected
and interoperate with other BinProlog users.
<P>
To override this default setting, one can use either
<P>
<TT><PRE>   set_host('my.full.internet.address')
</PRE></TT>
<P>
or temporarily override the default host by assuming it as a <TT>host/1</TT>
fact with
BinProlog's intuitionistic assumption. Such assumptions are scoped and
forgotten on backtracking. With
<P>
<TT><PRE>?-server_host('my.full.internet.address')=&gt;&gt;run_server.
</PRE></TT>
<P>
a given server is registered
on a master server given
by (also overridable):
<P>
<TT><PRE>default_master_server(Host,Port)
</PRE></TT>
<P>
An unrestricted server can run benign commands like
<P>
<TT><PRE>?-remote_run((write(hello),nl)).
</PRE></TT>
<P>
as well as more malicious ones like:
<P>
<TT><PRE>?-remote_run(pcollect('cat /etc/passwd',Answer))
</PRE></TT>
<P>
to collect password information ready for 
one's favorite cracking algorithm.
<P>
Note that registered servers are in principle accessible
to other users and therefore <EM>not</EM> secure.
<P>
Next, we will  give  two simple approaches to implement security.
<P>
<H2><A NAME="SECTION00042000000000000000">A first approach to security: servers with restricted interactors</A></H2>
<P>
Here is the code of the chat server:
<P>
<TT><PRE>chat_server_interactor(mes(From,Cs),Answer):-show_mes(From,Cs,Answer).
chat_server_interactor(ping(T),R):-term_server_interactor(ping(T),R).

chat_server:-
  server_interactor(chat_server_interactor)=&gt;&gt;
  run_server.
</PRE></TT>
<P>
By overriding the default 
<TT>server_interactor</TT> with our <TT>chat_server_interactor</TT>
we tell to <TT>chat_server</TT> that only commands matching
known, secure operations (i.e. <TT>mes/2</TT> and <TT>ping/1</TT>) have to be 
performed on behalf of remote users.
<P>
This might look very simple but some of BinProlog's key
features (intuitionistic implication and higher-order
<TT>call/N</TT>) are used inside the `generic' server code 
(see file <TT>extra.pl</TT> in the BinProlog distribution)
to achieve this form of configurability.
<P>
Security is achieved by having specialized meta-interpreters
`filtering' requests on the server side.
Intuitionistic assumption is used to override the generic server's
<EM>interactor</EM>, i.e. the inner server operation filtering
allowed requests, while allowing reuse of most of the generic
server's code in an object oriented programming
style.
<P>
Here is some <EM>interactor</EM> code for
two other `secure' servers.
<P>
The first one (BinProlog's current default)
is a Linda Term server (to be started with <TT>run_server/0</TT>)
enhanced with moderately weak remote management commands.
It offers a good combination of security and convenience:
it only allows modifying its dynamic database remotely through
Linda operations and displaying
messages. It can be shut down remotely and checked if alive
and of course it can be subject to resource attacks
by malicious users. However it can do no harm to one's file
system and cannot be used to
collect information about one's computer.
<P>
<TT><PRE>term_server_interactor(cin(X),R):-serve_cin(X,R).
term_server_interactor(out(X),R):-serve_out(X,R).
term_server_interactor(cout(X),R):-serve_cout(X,R).
term_server_interactor(rd(X),R):-serve_rd(X,R).
term_server_interactor(all(X),Xs):-serve_facts(X,X,Xs).
term_server_interactor(all(X,G),Xs):-serve_collect(X,G,Xs).
term_server_interactor(id(R),R):-this_id(R).
term_server_interactor(ping(T),T):-ctime(T).
term_server_interactor(stop(Mes),yes):-assumel(server_done(Mes)).
term_server_interactor(halt(X),yes):-serve_halt(X).
term_server_interactor(mes(From,Cs),Answer):-
  show_mes(From,Cs,Answer).
term_server_interactor(proxy(H,P,Q),R):-
  ask_a_server(H,P,Q,A)-&gt;R=A;R=no.
term_server_interactor(in(X),R):-serve_cn(X,R).
</PRE></TT>
<P>
Note that this interactor even supports proxy forwarding
to a given host/port. Clearly, the secure execution
of forwarded queries is the responsibility of the 
proxy target.
<P>
<H2><A NAME="SECTION00043000000000000000">A second approach to security: starting an
Intranet specific master server</A></H2>
<P>
Keeping one's host/port information secret from other users
can be achieved by starting a master server local to a secure
physical or virtual Intranet.
<P>
For users behind a firewall, this might actually be the only
way to try out these operations as the default master server
might be unreachable.
<P>
A local master server on, e.g. port 7788 is started with something like:
<P>
<TT><PRE>?- master_server('my.secure.local.computer',7788)=&gt;run_master_server.
</PRE></TT>
<P>
Client and server programs intended to be
managed by a local master server will have simply
to assume a fact:
<P>
<TT><PRE>   master_server('my.secure.local.computer',7788).
</PRE></TT>
<P>
or set the master server with:
<P>
<TT><PRE>  set_master_server('my.secure.local.computer',7788)
</PRE></TT>
<P>
To keep the workload of the master server minimal, only when
an error is detected by a client, the master server is asked
to refresh its information and possibly remove dead servers
from its database.
<P>
<H1><A NAME="SECTION00050000000000000000">Interaction with Java Applets.</A></H1>
<P>
BinProlog starting from version 5.40 communicates with
our recently released Java based <EM>Linda Interactors</EM><A NAME="tex2html5" HREF="#243"><IMG ALIGN=BOTTOM ALT="gif" SRC="icons//foot_motif.gif" width="15" height="15"></A> special purpose trimmed down pure Prolog engines written
in Java which support the same unification based
Linda protocol as BinProlog.
The natural extension was to allow Java applets
to participate to the rest of our `peer-to-peer'
network of BinProlog interactors.
As creating a server component within a Java applet
is impossible due to Java's (ultra)-conservative
security policies we have simply written a receiving-end 
<EM>servant</EM> close to our
example in subsection <A HREF="html.html#simple">2</A>, which relies on a proxy server
on the site where the applet originates from,
for seamless integration in our world of
peer-to-peer interactors.
<P>
Here is the code for a more realistic servant,
multiplexed among multiple servers and usable inside
a Java applet.
<P>
<TT><PRE>run_servant:-
  default_server_interactor(Interactor),
  this_id(ID),
  out(servant_id(ID)), % registers this servant
  repeat,
    in(query(ServerId,Query)), % waits for a query
    (call(Interactor,Query,Reply)-&gt;Answer=Reply;Answer=no),
    % sends back an answer, if needed
    ( ServerId=[]-&gt;true % no reply sent to anonymous servers
    ; out(answer(ServerId,Answer))
    ),
  functor(Query,stop,_),  % stops when required
  !,
  in(servant_id(ID)).
</PRE></TT>
<P>
Note the presence of an overridable client-side interactor,
allowing the generic servant code to be easily reused/specialized.
Multiplexing is achieved by having each server's <TT>in/1</TT> and
<TT>out/1</TT>
data marked with 
unique <TT>server_id/1</TT> records.
The server side code for a single query is simply:
<P>
<TT><PRE>ask_servant(Query,Answer):-
   this_id(ID), 
   % identifies the server the query comes from
   out(query(ID,Query)), % asks servant
   in(answer(ID,R)),     % gets back answer
   Answer=R.
</PRE></TT>
<P>
To integrate multiple Java applet based clients
in our `Web of Worlds', we use a more complex
forwarding server, also available as equivalent Java
code, to be run as a BinProlog and/or Java daemon<A NAME="tex2html6" HREF="#251"><IMG ALIGN=BOTTOM ALT="gif" SRC="icons//foot_motif.gif" width="15" height="15"></A>
on the same machine as the HTTP server the applet comes from.
<P>
<TT><PRE>run_forwarding_server:-
  server_interactor(forwarding_server_interactor)=&gt;&gt;
  run_server.

forwarding_server_interactor(mes(From,Cs),R):-!,R=yes,
   forward_to_servants(mes(From,Cs)).
forwarding_server_interactor(Q,A):-
   term_server_interactor(Q,A).

forward_to_servants(Query):-
   clause(servant_id(_),true),
   assert(query([],Query)),
   fail.
forward_to_servants(_).
</PRE></TT>
<P>
Note that the forwarding server has the ability
to interact with multiple servants, in particular
with multiple Java applets.
<P>
<H1><A NAME="SECTION00060000000000000000">Mobile Code</A></H1>
<P>
We will shortly discuss here the basic Mobile Code
facilities we have implemented. Future work will
focus on building intelligent agent applications
on top of them.
<P>
<H2><A NAME="SECTION00061000000000000000">Remote code fetching</A></H2>
<P>
The following operations
<P>
<TT><PRE>host(Other_machine)=&gt;&gt;rload(File).
host(Other_machine)=&gt;&gt;code(File)=&gt;&gt;TopGoal.
host(Other_machine)=&gt;&gt;fetch_remote_operators.
</PRE></TT>
<P>
allow fetching remote files/operator definitions <TT>rload/1, fetch_remote_operators/0</TT> or
on-demand fetching of a predicate at a time from a remote
host during execution of <TT>TopGoal</TT>. This is basically the same
mechanism as the one implemented for Java applet code fetching,
except that we have also implemented a caching mechanism,
both at predicate level (predicates are cached as dynamic code
on the server to efficiently serve multiple clients)
and at file level, on the client side.
<P>
<H2><A NAME="SECTION00062000000000000000">Dynamic recompilation</A></H2>
<P>
Dynamic recompilation is used on the client side to speed-up heavily
used relatively non-volatile predicates.  With dynamically recompiled
consulted code, listing of sources and dynamic modification to any
predicate is available while average performance stays close to
statically compiled code (usually within a factor of 2-3).  Although
when code comes over the network, code fetching time becomes more
significant, the combination of remote code fetching and dynamic
recompilation is a powerful accelerator for distributed network
applications comparable with Java's just-in-time (JIT) compilation
technology.
<P>
<H2><A NAME="SECTION00063000000000000000">(Virtual) Mobile Agents</A></H2>
 <A NAME="virt">&#160;</A>
<P>
Implementing agents `roaming over' a set of
servers is a simple and efficient high-level operation.
First, we get the list of servers from the master server.
Then we iterate through the appropriate remote-call negotiation
with each site. Our agent's behavior is constrained through
security and resource limitations of participating interpreters,
having their own command filtering policies.
<P>
In particular, on a chat-only server, our roaming agent can only
display a message. If the local interpreter allows gathering
user information then our agent can collect it. If the local
interpreter allows question/answering our agent will actually
interact with the human user through the local server window.
<P>
Note that `mobile agents' do not have to be implemented
as code physically moved from one site to another.
In this sense we can talk about <EM>virtual mobile agents</EM>
which are actually sets of synchronized remote predicate calls
originating from a unique site, where most
of the code is based/executed, while code actually moved
can be kept to strict minimum, i.e. only a few
remotely asserted clauses<A NAME="tex2html7" HREF="#262"><IMG ALIGN=BOTTOM ALT="gif" SRC="icons//foot_motif.gif" width="15" height="15"></A>.
<P>
Our mobile agents are seen as <EM>`connection brokers'</EM>
between participating
independent server/client sites. For instance if two sites are
willing to have a private conversation or code exchange they can
do so by simply using the server/port/password information our
agent can help them to exchange.
<P>
Note that full metaprogramming combined with source-level mobile-code
have the potential of better security than byte-code level verification
as it happens in Java, as meaningful analysis and verification of
program properties is possible.
<P>
<H2><A NAME="SECTION00064000000000000000">Crafting mobile agent scripts</A></H2>
<P>
To give a flavor of how agent scripts are crafted in our framework
we will describe a <EM>complete example</EM> emphasizing the
idea of Virtual Mobile Agents described in section <A HREF="html.html#virt">6.3</A>.
<P>
Each file begins with predicate <TT>main/0</TT> which is BinProlog's
user-defined auto-start point.
<P>
The first file (<TT>script.pro</TT>) mostly dispatches Unix processes
creating the other tasks in separate cmdtool
windows (for demo purposes) of appropriate sizes.
<P>
Each file contains the code describing the behavior of
an agent. The file <TT>master.pl</TT> initiates a local master server
which keeps an updated list of all the existing servers
and their properties (unique id, host, port).
A secret pasword is used when asking the
master server to trigger remote action 
which, for instance, will shut down all the servers.
<P>
<TT><PRE>main:-
  run_local_master_server.

password(obey_me).
</PRE></TT>
<P>
The file <TT>agent.pl</TT> contains the code shared among different agents.
<TT>Main/0</TT> starts by registering an unrestricted server, allowing
execution of remote commands to the local master server.
It is programmed in object oriented style with default actions
to be performed by more specialized agents.
<P>
<TT><PRE>main:-
  default_master_server(_,P),
  master_server(localhost,P)=&gt;&gt;run_unrestricted_server.
  
password(obey_me).

introduce_myself:-
  login(I),
  make_cmd([&quot;I am &quot;,I,&quot; !&quot;],Cmd),
  write(Cmd),nl.

init_super:-introduce_myself.

run_super:-
  sleep(1),
  login(Who),gensym_no(Who,Mes),write(i_am(Who,Mes)),nl.

accept_mobile(GoalAndCode):-
   call(GoalAndCode).

reject_mobile(GoalAndCode):-
   write('mobile code not welcome, intruder attempted to attach:'),nl,
   write(GoalAndCode),nl.
</PRE></TT>
<P>
The predicates for accepting/rejecting mobile `visitors'
can be used to enforce such policies on a server.
<P>
The first agent has default initialization <TT>init/0</TT> and
its <TT>run/1</TT> action step set to reject visiting mobile agents.
<P>
<TT><PRE>:-[agent].

login('The First').

init:-init_super.

run(X):-
  run_super,
  reject_mobile(X).
</PRE></TT>
<P>
Note the use of the builtin <TT>login/1</TT> predicate
giving a unique identity to each agent.
<P>
The second agent is similar, except that
its <TT>run/1</TT> action step is set to accept mobile agents.
<P>
<TT><PRE>:-[agent].

login('The Second').

init:-init_super.

run(X):-run_super,
  accept_mobile(X).
</PRE></TT>
<P>
The mobile agent itself uses BinProlog's built-in
iteration over the servers
registered on the master server as a powerful remote execution
mechanism. In the presence of the <TT>to_all/1</TT> assumption,
BinProlog's client code reacts by iterating over the set of 
servers matching a given pattern (everything in this case).
This applies to
 every command, and in particular to remote execution requests
specified by <TT>do/1</TT>.
<P>
<TT><PRE>main:-
  yell(&quot;Hello all!&quot;),
  to_all(_)=&gt;&gt;animate(10),
  sleep(20),
  password(P),ask_master_server(halt(P),_).

password(obey_me).

master_server(localhost,9000).

do(X):-remote_run(X),!.
do(_).

animate(Fuel):-
  do(init),
  mobile_code(Code),
  for(I,1,Fuel),
    write(running(step,I)),nl,
    do(run(Code)),
  fail
; write(done),nl.

mobile_code((go:-write(visiting_you),nl)=&gt;&gt;go).
</PRE></TT>
<P>
The predicate <TT>animate/1</TT> iterates over the set of servers,
sending a small chunk of mobile code
to be assumed on each server and then executed.
Note that more sophisticated code migration schemes can be
set up quite easily by assuming <TT>code(SourceFile)</TT>, which
has the effect to lazily fetch to a given server the code
needed for the execution of a remote query.
<P>
Note the use of the built-in predicate <TT>yell/1</TT>, which broadcasts
a message over the set of registered servers. It is actually defined as
<P>
<TT><PRE>  yell(Mes):-to_all(_)=&gt;&gt;say(Mes).
</PRE></TT>
<P>
On top of this, BinProlog 5.75 implements a built-in Internet/Intranet chat
mechanism <TT>chat/0</TT>, allowing users sharing a master server to exchange messages. For one-server communication, the <TT>talk/0</TT> built-in allows Java applets on the same machine to exchange messages
among them and with BinProlog users.
<P>
<H1><A NAME="SECTION00070000000000000000">Related work</A></H1>
<P>
A very large number of research projects
have recently started on mobile agent programming.
Among the pioneers, Kahn and Cerf's Knowbots [<A HREF="html.html#knowbots">11</A>]
Among the most promising recent developments
Luca Cardelli's Oblique project at  Digital and
mobile agent applications [<A HREF="html.html#migratory">1</A>]
and IBM Japan's aglets [<A HREF="html.html#aglets">10</A>].
We share their emphasis on going beyond <EM>code mobility</EM>
as present in Java, for instance,
towards <EM>control mobility</EM>. We think that distributed containers
with ability to negotiate with agents the resulting
local and global behavior can offer a secure and flexible approach
to Internet aware distributed programming.
A growing number of sophisticated Web-based applications and tools
are on the way to be implemented in LP/CLP languages.
Among them, work with a similar emphasis on
remote execution, agents, virtual worlds can be found in
[<A HREF="html.html#ch_html">3</A>, <A HREF="html.html#ld_www">13</A>, <A HREF="html.html#lpnet96cabeza">4</A>, <A HREF="html.html#lpnet96eclipse">2</A>, <A HREF="html.html#lpnet96multiple">18</A>, <A HREF="html.html#lpnet96light">12</A>, <A HREF="html.html#lpnet96virtual">24</A>].
<P>
<H1><A NAME="SECTION00080000000000000000">Conclusion and future work</A></H1>
<P>
Our remote execution mechanisms
are based on a set of filtering interpreters which can be customized to
support arbitrary negotiations with remote agents and are plugged
in generic servers.
The practical implementation is built on proven client/server
technology, on top of a generic socket package, while
giving the illusion of a `Web of MOOs' with roaming mobile
agents at the next level of abstraction.
<P>
A Java based Linda implementation, using a minimal
set of logic programming components (unification, associative search)
has been recently released (the Java TermServer, available at
http://clement.info.umoncton.ca/BinProlog).
It allows to communicate bidirectionally with
BinProlog, allowing creation of
combined Java/Prolog mobile-agent programs. In particular,
Java applets can be used as front end in browsers instead of
the more resource consuming CGIs most of our
applications are currently based on.
It holds promise for smooth cooperation
with existing Java class hierarchies as well as various
BinProlog based components with
intelligence and flexible metaprogramming on the logic programming side
combined with visualization and WWW programming abilities on the Java
side.
<P>
Future work will focus on intelligent mobile agents integrating
knowledge and controlled natural language processing abilities,
following our previous work described in [<A HREF="html.html#DFRT96">6</A>, <A HREF="html.html#RDT97">17</A>, <A HREF="html.html#TDRB97chi">22</A>].
<P>
<H2><A NAME="SECTION00081000000000000000">Acknowledgement</A></H2>
<P>
We thank for support from NSERC (grants OGP0107411 and 611024), and from the
FESR of the Universit&#233; de Moncton. Koen De Bosschere is research 
associate with the Fund for Scientific Research - Flanders.
<P>
<P><A NAME="SECTIONREF"><H2>References</H2></A><P>
<DL COMPACT>
<DT><A NAME="migratory"><STRONG>1</STRONG></A><DD>
K. A. Bharat and L. Cardelli.
Migratory applications.
In <EM>Proceedings of the 8th Annual ACM Symposium on User
  Interface Software and Technology</EM>, November 1995.
<P>
  http://gatekeeper.dec.com/pub/DEC/SRC/research-reports/abstracts/src-rr-138.html.
<P>
<DT><A NAME="lpnet96eclipse"><STRONG>2</STRONG></A><DD>
Ph. Bonnet, L. Bressnan S., Leth, and B. Thomsen.
Towards ECLIPSE Agents on the Internet.
In Tarau et al. [<A HREF="html.html#lpnet96">23</A>].
http://clement.info.umoncton.ca/ lpnet.
<P>
<DT><A NAME="ch_html"><STRONG>3</STRONG></A><DD>
D. Cabeza and M. Hermenegildo.
html.pl: A HTML Package for (C)LP systems.
Technical report, 1996.
Available from http://www.clip.dia.fi.upm.es.
<P>
<DT><A NAME="lpnet96cabeza"><STRONG>4</STRONG></A><DD>
D. Cabeza and M. Hermenegildo.
The Pillow/CIAO Library for Internet/WWW Programming
  using Computational Logic Systems.
In Tarau et al. [<A HREF="html.html#lpnet96">23</A>].
http://clement.info.umoncton.ca/ lpnet.
<P>
<DT><A NAME="linda89"><STRONG>5</STRONG></A><DD>
N. Carriero and D. Gelernter.
Linda in context.
<EM>CACM</EM>, 32(4):444-458, 1989.
<P>
<DT><A NAME="DFRT96"><STRONG>6</STRONG></A><DD>
Veronica Dahl, Andrew Fall, Stephen Rochefort, and Paul Tarau.
A Hypothetical Reasoning Framework for NL Processing.
In <EM>Proc. 8th IEEE International Conference on Tools with
  Artificial Intelligence</EM>, Toulouse, France, November 1996.
<P>
<DT><A NAME="DT97AGNL"><STRONG>7</STRONG></A><DD>
Veronica Dahl, Paul Tarau, and Renwei Li.
Assumption Grammars for Processing Natural Language.
In Lee Naish, editor, <EM>Proceedings of the Fourteenth
  International Conference on Logic Programming</EM>, pages 256-270, MIT press,
  1997.
<P>
<DT><A NAME="dbt95a"><STRONG>8</STRONG></A><DD>
K. De Bosschere and P. Tarau.
Blackboard-based Extensions in Prolog.
<EM>Software -- Practice and Experience</EM>, 26(1):49-69, January
  1996.
<P>
<DT><A NAME="hodasiclp90"><STRONG>9</STRONG></A><DD>
Joshua S. Hodas and Dale Miller.
Representing objects in a logic programming language with scoping
  constructs.
In David D. H. Warren and Peter Szeredi, editors, <EM>Proceedings of
  the Seventh International Conference on Logic Programming</EM>, pages 511 - 526.
  MIT Press, June 1990.
<P>
<DT><A NAME="aglets"><STRONG>10</STRONG></A><DD>
IBM.
Aglets.
http://www.trl.ibm.co.jp/aglets.
<P>
<DT><A NAME="knowbots"><STRONG>11</STRONG></A><DD>
R. E. Kahn and V. G. Cerf.
The digital library project, volume i: The world of knowbots.
1988.
Unpublished manuscript, Corporation for National Research
  Initiatives, Reston, Va., Mar.
<P>
<DT><A NAME="lpnet96light"><STRONG>12</STRONG></A><DD>
S. W. Locke, A. Davison, and Sterling L.
Lightweight Deductive Databases for the World-Wide Web.
In Tarau et al. [<A HREF="html.html#lpnet96">23</A>].
http://clement.info.umoncton.ca/ lpnet.
<P>
<DT><A NAME="ld_www"><STRONG>13</STRONG></A><DD>
S. W. Loke and A. Davison.
Logic programming with the world-wide web.
In <EM>Proceedings of the 7th ACM Conference on Hypertext</EM>, pages
  235-245. ACM Press, 1996.
<P>
<DT><A NAME="Miller89Lex"><STRONG>14</STRONG></A><DD>
D. A. Miller.
Lexical scoping as universal quantification.
In Giorgio Levi and Maurizio Martelli, editors, <EM>Proceedings of
  the Sixth International Conference on Logic Programming</EM>, pages 268-283,
  Cambridge, Massachusetts London, England, 1989. MIT Press.
<P>
<DT><A NAME="Miller89Mod"><STRONG>15</STRONG></A><DD>
Dale Miller.
A logical analysis of modules in logic programming.
<EM>Journal of Logic Programming</EM>, 6(1 and 2):79-108, January/March
  1989.
<P>
<DT><A NAME="mycroftpoli"><STRONG>16</STRONG></A><DD>
Alan Mycroft and R. A. O'Keefe.
A polimorphic type system for prolog.
<EM>Artificial Intelligence</EM>, (23):295-307, 1984.
<P>
<DT><A NAME="RDT97"><STRONG>17</STRONG></A><DD>
Stephen Rochefort, Veronica Dahl, and Paul Tarau.
Controlling Virtual Worlds through Extensible Natural
  Language.
In <EM>AAAI Symposium on NLP for the WWW</EM>, Stanford University, CA,
  1997.
<P>
<DT><A NAME="lpnet96multiple"><STRONG>18</STRONG></A><DD>
Peter Szeredi, Katalin Moln&#225;r, and Rob Scott.
Serving Multiple HTML Clients from a Prolog Application.
In Tarau et al. [<A HREF="html.html#lpnet96">23</A>].
http://clement.info.umoncton.ca/ lpnet.
<P>
<DT><A NAME="Tarau97BinProlog"><STRONG>19</STRONG></A><DD>
Paul Tarau.
BinProlog 5.75 User Guide.
Technical Report 97-1, D&#233;partement d'Informatique, Universit&#233;
  de Moncton, April 1997.
Available from <EM>http://clement.info.umoncton.ca/BinProlog</EM>.
<P>
<DT><A NAME="TD96coord"><STRONG>20</STRONG></A><DD>
Paul Tarau and Veronica Dahl.
A Coordination Logic for Agent Programming in Virtual
  Worlds.
In Wolfram Conen and Gustaf Neumann, editors, <EM>Proceedings of
  Asian'96 Post-Conference Workshop on Coordination Technology for
  Collaborative Applications</EM>, Singapore, December 1996.
to appear in LNCS, Springer.
<P>
<DT><A NAME="TDFasian96"><STRONG>21</STRONG></A><DD>
Paul Tarau, Veronica Dahl, and Andrew Fall.
Backtrackable State with Linear Affine Implication and
  Assumption Grammars.
In Joxan Jaffar and Roland H.C. Yap, editors, <EM>Concurrency and
  Parallelism, Programming, Networking, and Security</EM>, Lecture Notes in
  Computer Science 1179, pages 53-64, Singapore, December 1996. Springer.
<P>
<DT><A NAME="TDRB97chi"><STRONG>22</STRONG></A><DD>
Paul Tarau, Veronica Dahl, Stephen Rochefort, and Koen De Bosschere.
LogiMOO: a Multi-User Virtual World with Agents and
  Natural Language Programming.
In S. Pemberton, editor, <EM>Proceedings of CHI'97</EM>, pages 323-324,
  March 1997.
ACM ISBN 0-8979-926-2.
<P>
<DT><A NAME="lpnet96"><STRONG>23</STRONG></A><DD>
Paul Tarau, Andrew Davison, Koen De Bosschere, and Manuel Hermenegildo,
  editors.
<EM>Proceedings of the 1st Workshop on Logic Programming Tools for
  INTERNET Applications</EM>, JICSLP'96, Bonn, September 1996.
http://clement.info.umoncton.ca/ lpnet.
<P>
<DT><A NAME="lpnet96virtual"><STRONG>24</STRONG></A><DD>
Paul Tarau and Koen De Bosschere.
Virtual World Brokerage with BinProlog and Netscape.
In Tarau et al. [<A HREF="html.html#lpnet96">23</A>].
http://clement.info.umoncton.ca/ lpnet.
</DL>
<P>
<DL> <DT><A NAME="163">...MOO</A><DD>Multi User Domains (MUDs), Object Oriented - venerable but
still well doing ancestors of more recent multi-user Virtual Worlds,
which are usually 3D-animation (VRML) based
<PRE>
</PRE><DT><A NAME="192">...site</A><DD>In particular it allows what Microsoft never 
could/wanted to build in Windows 95 or NT: remote shell commands.
In particular, by starting a BinProlog server on a machine with
Windows 95/NT it is possible to do meaningful work on it remotely
from another Windows 95/NT or Unix machine.
<PRE>
</PRE><DT><A NAME="243">...Interactors</A><DD>available at http://clement.info.umoncton/BinProlog/LindaInteractor.tar.gz
<P>
<PRE>
</PRE><DT><A NAME="251">...daemon</A><DD>Alternatively,
BinProlog can be embedded as a server side include in an
Apache server (written in C) while the equivalent Java code 
is easily embeddable in the Java based Jigsaw HTTP server.
<PRE>
</PRE><DT><A NAME="262">...clauses</A><DD>Note however that suspending execution
at one site, and then restarting it at another
site can be done quite efficiently in BinProlog, where
continuations are first order objects which can be
put into a term to be sent over a socket, then read in
and executed.
<PRE>
</PRE> </DL>
<BR> <HR>
<P><ADDRESS>
<I>Paul Tarau <BR>
Tue Sep  2 21:27:02 ADT 1997</I>
</ADDRESS>
</BODY>
</HTML>
