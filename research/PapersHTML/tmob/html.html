<!DOCTYPE HTML PUBLIC "-//IETF//DTD HTML 2.0//EN">
<!--Converted with LaTeX2HTML .95.3 (Nov 17 1995) by Nikos Drakos (nikos@cbl.leeds.ac.uk), CBLU, University of Leeds -->
<HTML>
<HEAD>
<TITLE>Mobile Threads through First Order Continuations</TITLE>
<meta name="description" value="Mobile Threads through First Order Continuations">
<meta name="keywords" value="html">
<meta name="resource-type" value="document">
<meta name="distribution" value="global">
<LINK REL=STYLESHEET HREF="html.css">
</HEAD>
<BODY LANG="EN"  bgcolor=white>
<P>    

<P>
<H1 ALIGN=CENTER>Mobile Threads through First Order Continuations</H1>
<P ALIGN=CENTER><STRONG>
 Paul Tarau1 and Veronica Dahl2
</STRONG></P><P>
<P ALIGN=CENTER><STRONG></STRONG></P><br><br><P>

    Universit&#233; de Moncton<BR>
    D&#233;partement d'Informatique<BR>
    Moncton, N.B.  Canada E1A 3E9,<BR>
    tarau@info.umoncton.ca
    <p> 
     Logic and Functional Programming Group<BR>
     Department of Computing Sciences<BR>
     Simon Fraser University<BR>
     Burnaby, B.C. Canada V5A 1S6<BR>
     veronica@cs.sfu.ca<BR>
     
<P>
<H3 CLASS=ABSTRACT>Abstract:</H3>
<P CLASS=ABSTRACT><EM>Mobile threads are implemented by capturing 
first order continuations
in a compact data structure sent over the network.
Code is fetched lazily from its original base turned into a server
as the continuation executes at the remote site.
Our techniques, in combination with a dynamic recompilation scheme
ensuring that heavily used code moves up smoothly on a speed
hierarchy, are shown to be
an effective means for implementing mobile agents.
<P>
<EM>Keywords:
  mobile computations, remote execution, metaprogramming, 
  first order continuations, Linda coordination, 
  blackboard-based logic programming, 
  mobile code, mobile agents
</EM>
</EM></P><P>
<H1><A NAME="SECTION00010000000000000000">Introduction</A></H1>
 <A NAME="intro">&#160;</A>
<P>
<EM>Data mobility</EM> has been present since
the beginning of networked computing, and is
now used in numerous applications -
from remote consultation of a database, to
Web browsing.
<P>
<EM>Code mobility</EM> followed, often in disguised form,
with human hand waiving being part of the <EM>workflow</EM>,
as is still the case 
with ftp-transferred, untarred-uncompressed and makefile-hacked
Unix installs.
More transparently, executables coming over network 
file systems on intranets as well as
self-installing Windows programs are all instances of mobile
code. Self-updating software is probably the maximum of functionality
which can be expressed in this framework.
The most well-known example of code mobility is Java's ability
to execute applets directly in client browsers in a fairly secure way
through dynamic class fetching and bytecode verification.
<P>
Migrating the state of the computation from one machine or process to
another still requires a separate set of tools. Java's remote method
invocations (RMI) add <EM>control mobility</EM>
and a (partially) automated form of <EM>object mobility</EM>
i.e. integrated code (class) and data (state) mobility.
<P>
The Oz 2.0 distributed programming proposal of [<A HREF="html.html#DOZmobility">25</A>]
makes <EM>object mobility</EM> more
transparent, although the mobile entity is still
the state of the objects, not ``live'' code.
<P>
Mobility of ``live code'' is called <EM>computation mobility</EM> [<A HREF="html.html#cardelli97mobile">3</A>].
It requires interrupting execution, moving the state of a runtime system
(stacks, for instance) from one site to another and then resuming
execution. Clearly, for some languages, this can be hard or completely
impossible to achieve.
<P>
Telescript and General Magic's new 
Odyssey [<A HREF="html.html#odissey">9</A>] agent programming
framework, IBM's Java based <EM>aglets</EM> as well as
Luca Cardelli's Oblique [<A HREF="html.html#migratory">1</A>]
have pioneered implementation technologies achieving
<EM>computation mobility</EM>.
<P>
Towards the same objective, this paper will show that we can achieve
full <EM>computation mobility</EM> through our
<EM>mobile threads</EM>.
They are implemented by a surprisingly small, source level
modification of the BinProlog system, taking advantage of
the availability of `first order' 
continuations<A NAME="tex2html1" HREF="#104"><IMG ALIGN=BOTTOM ALT="gif" SRC="icons//foot_motif.gif" width="15" height="15"></A> as well as 
of BinProlog's high level networking primitives.
Mobile threads complete our Logic Programming based Internet
programming infrastructure built in view of
creating Prolog components which can interoperate
with mainstream languages and programming environments.
<EM>Mobile threads</EM> can be seen as a refinement of <EM>mobile
computations</EM> as corresponding to <EM>mobile partial computations</EM>
of any granularity. <EM>Mobile agents</EM> can be seen as a collection
of synchronized <EM>mobile threads</EM> sharing common 
state [<A HREF="html.html#TD96coord">16</A>].
<P>
The paper is organized as follows:
<UL><LI> section <A HREF="html.html#infra">2</A> describes our networking infrastructure and Linda based client/server components
<LI> section <A HREF="html.html#mobcode">3</A> introduces code mobility primitives
<LI>  section <A HREF="html.html#engines">4</A> describes engines and threads
<LI> section <A HREF="html.html#bin">5</A> 
  explains how continuations are represented as data structures
<LI> section <A HREF="html.html#mobthreads">6</A> explains how we implement thread mobility 
   by capturing continuations (subsection <A HREF="html.html#capt">6.1</A>)
   and by moving them from their base to their target 
     (subsection <A HREF="html.html#contmoving">6.2</A>)
<LI> section <A HREF="html.html#mobags">8</A> describes how mobile agents can be built
   with our framework
<LI> section <A HREF="html.html#rel">9</A> discusses related work
<LI> section <A HREF="html.html#conc">10</A> presents our conclusions and future work
</UL>
<P>
Our Internet programming infrastructure and 
in particular the technologies
we have designed and implemented for
code and control mobility are new in the logic programming domain.
The main ``paradigm independent'' novelties of our contribution are:
<P>
<UL><LI> use of first order continuations for implementing <EM>mobile computations</EM>
<LI> expressing thread mobility in terms of client-server role alternation
</UL><H1><A NAME="SECTION00020000000000000000">A Logic Programming based Internet Programming Infrastructure</A></H1>
 <A NAME="infra">&#160;</A>
<P>
We refer to [<A HREF="html.html#TDBwetice97">17</A>] for the details of
our high-level client-server programming primitives and
security issues and to [<A HREF="html.html#Tarau97BinProlog">14</A>] for
the platform independent and Java-compatible
socket-level primitives of BinProlog.
<P>
Our networking constructs are built on the top of the popular
Linda [<A HREF="html.html#linda89">4</A>] coordination framework,
enhanced with unification based pattern
matching, remote execution and a set of simple 
client-server components
melted together into a scalable peer-to-peer
layer, forming a `web of interconnected worlds':
<P>
<PRE>out(X): puts X on the server
in(X):  waits until it can take an object matching X from the server
all(X,Xs): reads the list Xs matching X currently on the server
remote_run(Goal): starts a thread executing Goal on server
stop_server: stops the server
</PRE>
<P>
The presence of the <TT>all/2</TT> collector compensates for
the lack of non-deterministic operations.
Note that the only blocking operation is <TT>in/1</TT>.
Blocking <TT>rd/1</TT> is easily
emulated in terms of <TT>in/1</TT> and <TT>out/1</TT>,
while non-blocking <TT>rd/1</TT> is emulated with <TT>all/2</TT>.
<P>
<P><A NAME="418">&#160;</A><A NAME="linda">&#160;</A> <IMG WIDTH=289 HEIGHT=179 ALIGN=BOTTOM ALT="figure410" SRC="img1.gif"  > <BR>
<STRONG> 1:</STRONG> Basic Linda operations<BR>
<P><H2><A NAME="SECTION00021000000000000000">A Servant: a simple Linda based BinProlog agent</A></H2>
 <A NAME="servant">&#160;</A>
<P>
A <EM>servant</EM> is one of the simplest possible <EM>agents</EM>,
which pulls commands from a server and runs them locally:
<P>
<PRE>servant:-
  in(todo(Task)),
  call(Task),
  servant.
</PRE>
<P>
Note that <EM>servant</EM> is  started as a background thread.
No `busy wait' is involved,
as the servant's thread
blocks until <TT>in(todo(Task))</TT>
succeeds.
More generally, distributed event processing is implemented
by creating a `watching' agent attached to a thread
for each pattern.
<P>
As <EM>servants</EM>
pulling commands are operationally indistinguishable from
<EM>servers</EM> acting upon clients' requests, they
can be used as emulators for <EM>servers</EM>.
A class of obvious applications of this ability
is their use as pseudo-servers running on
machines with dynamically allocated
IP addresses (as offered by most ISP today),
laying behind firewalls.
This mechanism also works when, because of
security restrictions, server components
cannot be reached from outside, as in the case of
<EM>Java applets</EM> which cannot listen on ports of
the client side machine.
<P>
<H4><A NAME="SECTION00021010000000000000">Interaction with Java Applets.</A></H4>
<P>
To avoid Java security restrictions, an applet emulates
a <EM>BinProlog servant</EM>, using an interface module
written in Java called a <EM>Linda Interactor</EM>.
BinProlog communicates with this
special purpose trimmed down pure Prolog engine
which supports the same unification based
Linda protocol as BinProlog and acts as a gateway
between knowledge processing components written in Prolog
and visual and reactive components written in Java.
In particular, this design allows Java applets
to cooperate with the rest of our `peer-to-peer'
network of BinProlog interactors,
as the Java servant simply
pulls out commands from a proxy server
on the site where the applet originates from.
<P>
<H2><A NAME="SECTION00022000000000000000">Server side code</A></H2>
<P>
Servants as well as other clients can connect to
BinProlog <EM>servers</EM>.
Higher order <EM>call/N</EM> [<A HREF="html.html#mycroftpoli">12</A>], 
combined with intuitionistic assumptions <TT>``=&gt;&gt;''</TT>,
are used to pass arbitrary <EM>interactors</EM> to
generic server code:
<P>
<PRE>run_server(Port):-
  new_server(Port,Server),
  register_server(Port),
  server(Server)=&gt;&gt;server_loop,
  close_socket(Server).

server_loop:-
  repeat,
    interact,   
  assumed(server_done),
  !.

interact:-
  assumed(Interactor),
  assumed(Server),
  % higher-order call to interactor 
  call(Interactor,Server).
</PRE>
<P>
Note the use of a specialized <EM>server-side</EM> interpreter
<TT>server_loop</TT>, configurable through the use of higher-order 
`question/answer' closures we have called <EM>interactors</EM>.
<P>
The components of a `generic' default server can be 
overridden through the use of <EM>intuitionistic
implication</EM> to obtain customized special purpose servers.
The use of intuitionistic implications  
 (pioneered by
Miller's work [<A HREF="html.html#Miller89Lex">11</A>]) helps to overcome 
(to some extent) Prolog's lack
of object oriented programming facilities,
by allowing us to `inject' the right interactor into
the generic (and therefore reusable) interpreter.
BinProlog's <TT>``=&gt;&gt;''</TT> temporarily assumes a clause
in <TT>asserta</TT> order, i.e. at the beginning of the predicate.
The assumption is scoped to be only usable to prove its
right side goal and vanishes on backtracking.
We refer to [<A HREF="html.html#Tarau97BinProlog">14</A>, <A HREF="html.html#TDFasian96">20</A>, <A HREF="html.html#DT97AGNL">6</A>]
for more information on assumptions and their applications.
<P>
<H2><A NAME="SECTION00023000000000000000">Master Servers: Connecting a Web of Worlds</A></H2>
<P>
The MOO<A NAME="tex2html4" HREF="#175"><IMG ALIGN=BOTTOM ALT="gif" SRC="icons//foot_motif.gif" width="15" height="15"></A> 
inspired `web of worlds' metaphor [<A HREF="html.html#TDRB97chi">21</A>, <A HREF="html.html#lpnet96virtual">23</A>] 
implemented as
as a set of BinProlog and Java based 
Linda <EM>blackboards</EM> storing <EM>state information</EM>
on servers connected over the the Internet, allows a simple and secure
remote execution mechanism through specialized <EM>server-side</EM> interpreters.
<P>
A <EM>virtual place</EM> (world) is implemented as a server listening
on a port which can spawn clients in the same
or separate threads interacting with other servers
through a simple question/answer protocol.
<P>
<P><A NAME="430">&#160;</A><A NAME="master">&#160;</A> <IMG WIDTH=287 HEIGHT=181 ALIGN=BOTTOM ALT="figure422" SRC="img2.gif"  > <BR>
<STRONG> 2:</STRONG> A Web of Worlds<BR>
<P>
<P>
A master server on a `well-known' host/port
is used to exchange identification information among peers composed
of clients and a server (Fig. <A HREF="html.html#master">2</A>),
usually running as threads of the same process.
<P>
<H2><A NAME="SECTION00024000000000000000">Remote execution mechanisms</A></H2>
 <A NAME="remote">&#160;</A>
<P>
Implementation of arbitrary remote execution is easy
in a Linda + Prolog system, due to Prolog's <EM>metaprogramming</EM>
abilities. No complex serialization/remote object 
packages are needed. Our primitive remote call operation is:
<P>
<PRE>host(Other_machine)=&gt;&gt;remote_run(Answer,RemoteGoal).
</PRE>
<P>
It implements deterministic <EM>remote predicate calls</EM> 
with (first)-answer or <TT>`no'</TT> returned to the calling site.
<P>
For instance, to iterate over the set of servers forming
the receiving end of our `Web of Worlds', after retrieving
the list from a `master server' which constantly monitors
them making sure that the list reflects login/logout
information, we simply override <TT>host/1</TT> and <TT>port/1</TT> with
intuitionistic implication:
<P>
<PRE>ask_all_servers(Channel,ListOfServers,Question):-
  member(server_id(Channel,H,P),ListOfServers),
  host(H)=&gt;&gt;port(P)=&gt;&gt;
    ask_a_server(Question,_),
  fail;true.
</PRE>
<P>
Note that a <TT>Channel</TT> pattern is used to select a subset
of relevant servers, and in particular, when <TT>Channel</TT> is
a ``match all'' free logical variable,  all of them.
<P>
<H1><A NAME="SECTION00030000000000000000">Mobile Code</A></H1>
 <A NAME="mobcode">&#160;</A>
<P>
We will shortly discuss here the basic Mobile Code
facilities we have implemented.
<P>
<H2><A NAME="SECTION00031000000000000000">Lazy code fetching</A></H2>
<P>
In BinProlog, code fetched lazily, one predicate at a time, as needed by the execution flows over the network.
<P>
Code is cached in a local database and then
dynamically recompiled on the fly if usage statistics
indicate that it is <EM>not volatile</EM> and it is <EM>heavily used</EM>
locally.
<P>
The following operations
<P>
<PRE>host(Other_machine)=&gt;&gt;rload(File).
host(Other_machine)=&gt;&gt;code(File)=&gt;&gt;TopGoal.
</PRE>
<P>
allow fetching remote files <TT>rload/1</TT> or
on-demand fetching of a predicate at a time from a remote
host during execution of TopGoal. This is basically the same
mechanism as the one implemented for Java applet code fetching,
except that we have also implemented a caching mechanism,
at predicate level (predicates are cached as dynamic code
on the server to efficiently serve multiple clients).
<P>
Dynamic recompilation is used on the client side to speed-up heavily
used, relatively non-volatile predicates.  With dynamically recompiled
consulted code, listing of sources and dynamic modification to any
predicate is available, while average performance stays close to
statically compiled code (usually within a factor of 2-3).  Although
when code comes over the network, code fetching time becomes more
significant, the combination of lazy remote code fetching and dynamic
recompilation is a powerful accelerator for distributed network
applications.
<P>
<H2><A NAME="SECTION00032000000000000000">Dynamic recompilation</A></H2>
<P>
Our implementation of dynamic recompilation for BinProlog 
is largely motivated by the difficulty/complexity of relying on the programmer
to specify execution methods for remote code.
<P>
The intuition behind the dynamic recompilation algorithm of BinProlog is
that <EM>update</EM> vs. <EM>call</EM> based <EM>statistics</EM> are associated
to each predicate declared or detected as dynamic.
Dynamic (re)compilation is triggered for relatively non-volatile predicates,
which are promoted on the <EM>`speed-hierarchy'</EM> to a faster
implementation method (interpreted <tex2html_verb_mark><tex2html_verb_mark> bytecode <tex2html_verb_mark><tex2html_verb_mark> native).  
The process is restarted from the `easier to change' interpreted
representation, kept in memory in a compact form,
upon an update.
<P>
We can describe  BinProlog's dynamic <EM>`recompilation
triggering statistics'</EM> through a simple `thermostat' metaphor.
<EM>Updates</EM> (assert/retract) to a predicate have the effect of increasing its
associated `temperature', while <EM>Calls</EM>
will decrease it. Non-volatile (`cool') predicates 
are dynamically recompiled, while recompilation is avoided for volatile (`hot') predicates.
A <EM>ratio</EM> based on cooling factors (number of calls,
compiled/interpreted execution speed-up etc.) and
heating factors (recompilation time, number of updates etc.)
smoothly adjusts for optimal overall performance,
usually within a factor of 2 from static code.
<P>
<H1><A NAME="SECTION00040000000000000000">Engines and Answer Threads</A></H1>
 <A NAME="engines">&#160;</A>
<P>
<H2><A NAME="SECTION00041000000000000000">Engines</A></H2>
<P>
BinProlog allows launching
multiple Prolog engines having their own stack groups (heap, local stack
and trail). An engine can be seen as an abstract data-type which
produces a (possibly infinite) stream of solutions as needed.
To create an new engine, we use:
<P>
<PRE>  % :-mode create_engine(+,+,+,-).
  create_engine(HeapSize,StackSize,TrailSize,Handle)
</PRE>
<P>
or, by using default parameters for the stacks:
<P>
<PRE>  % :-mode create_engine(-).
  create_engine(Handle)
</PRE>
<P>
The <TT>Handle</TT> is a unique integer denoting the engine for further
processing.
To `fuel' the engine with a goal and an expected answer variable
we use:
<P>
<PRE>  % :-mode load_engine(+,+,+).
  load_engine(Handle,Goal,AnswerVariable)
</PRE>
<P>
No processing, except the initialization of the
engine takes place, and no answer
is returned with this operation.
<P>
To get an answer from the engine we use:
<PRE>  % :-mode ask_engine(+,-).
  ask_engine(Handle,Answer)
</PRE>
<P>
Each engine has its own heap garbage collection process
and backtracks independently using its choice-point stack and trail
during the computation of an answer.
Once computed, an answer is copied from an engine to its ``master''.
<P>
When the stream of answers reaches its end, <tex2html_verb_mark><tex2html_verb_mark>
will simply fail. The resolution process in an engine
can be discarded at any time by simply loading another goal
with <TT>load_engine/3</TT>. This allows avoiding the
cost of backtracking, for instance in the case when a single
answer is needed, as well as garbage collection costs.
<P>
If for some reason we are not interested in the engine any more,
we can free the space allocated to the engine and completely discard it with:
<P>
<PRE>  % :-mode destroy_engine(+).
  destroy_engine(Handle)
</PRE>
<P>
The following example (see more in files 
<TT>library/engines, progs/engtest.pl</TT> in the BinProlog distribution [<A HREF="html.html#Tarau97BinProlog">14</A>])
shows a sequence of the previously described operations:
<P>
<PRE> ?-create_engine(E),
   load_engine(E,append(As,Bs,[A,B,B,A]),As+Bs),
   ask_engine(E,R1),write(R1),nl,
   ask_engine(E,R2),write(R2),nl,
   destroy_engine(E).
</PRE>
<P>
<P><A NAME="442">&#160;</A><A NAME="ortho">&#160;</A> <IMG WIDTH=288 HEIGHT=213 ALIGN=BOTTOM ALT="figure434" SRC="img3.gif"  > <BR>
<STRONG> 3:</STRONG> Orthogonal Engines<BR>
<P>
<P>
Multiple  `orthogonal engines' as shown in Figure <A HREF="html.html#ortho">3</A>
enhance the expressiveness of
Prolog by allowing an AND-branch of an engine to
collect answers from multiple OR-branch of another engine.
They give to the programmer the means to see
as an abstract sequence and control, the answers
produced by an engine, in a way
similar to Java's <TT>Enumeration</TT> interface.
<P>
<H2><A NAME="SECTION00042000000000000000">Threads</A></H2>
<P>
Engines can be assigned to their own thread by using
BinProlog's POSIX thread package.
A unique primitive is needed,
<PRE>   ask_thread(E,R)
</PRE>
<P>
which launches a new thread <TT>R</TT> to perform the computation of
an answer of engine <TT>E</TT>.
On top of this facility each thread can implement a separate server,
client or become the base of a mobile agent.
<P>
<H1><A NAME="SECTION00050000000000000000">First order Continuations through Binarization</A></H1>
 <A NAME="bin">&#160;</A>
<P>
We will shortly explain here BinProlog's continuation passing
preprocessing technique, which results in availability of
continuations as data structures accessible to the programmer.
<P>
<H4><A NAME="SECTION00050010000000000000">The binarization transformation</A></H4>
<P>
Binary clauses have only one atom in the body 
(except for some in-line `builtin' operations like arithmetics),
and therefore they need no `return' after a call.
A transformation introduced in [<A HREF="html.html#Tarau90PLILP">15</A>] allows to
faithfully represent logic programs with operationally equivalent
binary programs.
To keep things simple, we will describe our transformations in the case
of definite programs.
We will follow here the notations of [<A HREF="html.html#pt93b">22</A>].
<P>
Let us define the <EM>composition</EM> operator  <IMG WIDTH=11 HEIGHT=18 ALIGN=MIDDLE ALT="tex2html_wrap_inline814" SRC="img4.gif"  >  
that combines clauses by unfolding the leftmost body-goal
of the first argument.
<P>
Let <TT>A <IMG WIDTH=6 HEIGHT=11 ALIGN=MIDDLE ALT="tex2html_wrap_inline816" SRC="img5.gif"  > :-A <IMG WIDTH=4 HEIGHT=11 ALIGN=MIDDLE ALT="tex2html_wrap_inline818" SRC="img6.gif"  > ,A <IMG WIDTH=6 HEIGHT=11 ALIGN=MIDDLE ALT="tex2html_wrap_inline820" SRC="img7.gif"  > ,...,A <IMG WIDTH=8 HEIGHT=6 ALIGN=MIDDLE ALT="tex2html_wrap_inline822" SRC="img8.gif"  > </TT> and 
<TT>B <IMG WIDTH=6 HEIGHT=11 ALIGN=MIDDLE ALT="tex2html_wrap_inline824" SRC="img9.gif"  > :-B <IMG WIDTH=4 HEIGHT=11 ALIGN=MIDDLE ALT="tex2html_wrap_inline826" SRC="img10.gif"  > ,...,B <IMG WIDTH=11 HEIGHT=6 ALIGN=MIDDLE ALT="tex2html_wrap_inline828" SRC="img11.gif"  > </TT> be two clauses (suppose  <IMG WIDTH=89 HEIGHT=22 ALIGN=MIDDLE ALT="tex2html_wrap_inline830" SRC="img12.gif"  > ). We define 
<TT>(A <IMG WIDTH=6 HEIGHT=11 ALIGN=MIDDLE ALT="tex2html_wrap_inline832" SRC="img13.gif"  > :-A <IMG WIDTH=4 HEIGHT=11 ALIGN=MIDDLE ALT="tex2html_wrap_inline834" SRC="img14.gif"  > ,A <IMG WIDTH=6 HEIGHT=11 ALIGN=MIDDLE ALT="tex2html_wrap_inline836" SRC="img15.gif"  > ,...,A <IMG WIDTH=8 HEIGHT=6 ALIGN=MIDDLE ALT="tex2html_wrap_inline838" SRC="img16.gif"  > )</TT>  <IMG WIDTH=11 HEIGHT=18 ALIGN=MIDDLE ALT="tex2html_wrap_inline840" SRC="img17.gif"  >  
<TT>(B <IMG WIDTH=6 HEIGHT=11 ALIGN=MIDDLE ALT="tex2html_wrap_inline842" SRC="img18.gif"  > :-B <IMG WIDTH=4 HEIGHT=11 ALIGN=MIDDLE ALT="tex2html_wrap_inline844" SRC="img19.gif"  > ,...,B <IMG WIDTH=11 HEIGHT=6 ALIGN=MIDDLE ALT="tex2html_wrap_inline846" SRC="img20.gif"  > ) = (A <IMG WIDTH=6 HEIGHT=11 ALIGN=MIDDLE ALT="tex2html_wrap_inline848" SRC="img21.gif"  > :-B <IMG WIDTH=4 HEIGHT=11 ALIGN=MIDDLE ALT="tex2html_wrap_inline850" SRC="img22.gif"  > ,...,B <IMG WIDTH=11 HEIGHT=6 ALIGN=MIDDLE ALT="tex2html_wrap_inline852" SRC="img23.gif"  > ,A <IMG WIDTH=6 HEIGHT=11 ALIGN=MIDDLE ALT="tex2html_wrap_inline854" SRC="img24.gif"  > ,...,A <IMG WIDTH=8 HEIGHT=6 ALIGN=MIDDLE ALT="tex2html_wrap_inline856" SRC="img25.gif"  > )</TT> <IMG WIDTH=7 HEIGHT=12 ALIGN=BOTTOM ALT="tex2html_wrap_inline858" SRC="img26.gif"  > 
<P>
with  <IMG WIDTH=7 HEIGHT=12 ALIGN=BOTTOM ALT="tex2html_wrap_inline860" SRC="img27.gif"  >  = mgu(<TT>A <IMG WIDTH=4 HEIGHT=11 ALIGN=MIDDLE ALT="tex2html_wrap_inline862" SRC="img28.gif"  > </TT>,<TT>B <IMG WIDTH=6 HEIGHT=11 ALIGN=MIDDLE ALT="tex2html_wrap_inline864" SRC="img29.gif"  > </TT>). If the atoms <TT>A <IMG WIDTH=4 HEIGHT=11 ALIGN=MIDDLE ALT="tex2html_wrap_inline866" SRC="img30.gif"  > </TT> and
<TT>B <IMG WIDTH=6 HEIGHT=11 ALIGN=MIDDLE ALT="tex2html_wrap_inline868" SRC="img31.gif"  > </TT> do not unify, the result of the composition is denoted as  <IMG WIDTH=11 HEIGHT=11 ALIGN=BOTTOM ALT="tex2html_wrap_inline870" SRC="img32.gif"  > .
Furthermore, as usual, we consider <TT>A <IMG WIDTH=6 HEIGHT=11 ALIGN=MIDDLE ALT="tex2html_wrap_inline872" SRC="img33.gif"  > :-true,A <IMG WIDTH=6 HEIGHT=11 ALIGN=MIDDLE ALT="tex2html_wrap_inline874" SRC="img34.gif"  > ,...,A <IMG WIDTH=8 HEIGHT=6 ALIGN=MIDDLE ALT="tex2html_wrap_inline876" SRC="img35.gif"  > </TT> 
to be equivalent to <TT>A <IMG WIDTH=6 HEIGHT=11 ALIGN=MIDDLE ALT="tex2html_wrap_inline878" SRC="img36.gif"  > :-A <IMG WIDTH=6 HEIGHT=11 ALIGN=MIDDLE ALT="tex2html_wrap_inline880" SRC="img37.gif"  > ,...,A <IMG WIDTH=8 HEIGHT=6 ALIGN=MIDDLE ALT="tex2html_wrap_inline882" SRC="img38.gif"  > </TT>, and for any clause <TT>C</TT>, <TT> <IMG WIDTH=11 HEIGHT=11 ALIGN=BOTTOM ALT="tex2html_wrap_inline884" SRC="img39.gif"  >   <IMG WIDTH=11 HEIGHT=18 ALIGN=MIDDLE ALT="tex2html_wrap_inline886" SRC="img40.gif"  >  C = C  <IMG WIDTH=11 HEIGHT=18 ALIGN=MIDDLE ALT="tex2html_wrap_inline888" SRC="img41.gif"  >   <IMG WIDTH=11 HEIGHT=11 ALIGN=BOTTOM ALT="tex2html_wrap_inline890" SRC="img42.gif"  >  =  <IMG WIDTH=11 HEIGHT=11 ALIGN=BOTTOM ALT="tex2html_wrap_inline892" SRC="img43.gif"  > </TT>.
We assume that at least one operand has been renamed to a variant with
 variables standardized apart.
<P>
This Prolog-like inference rule is called LD-resolution and it has
the advantage of giving a more accurate description of Prolog's operational semantics than SLD-resolution.
Before introducing the binarization transformation, we describe two
auxiliary transformations.
<P>
The first transformation converts facts into rules by  giving
them the atom <TT>true</TT> as body. E.g., the fact <TT>p</TT> is
transformed into the rule <TT>p :- true</TT>.
<P>
The second transformation, inspired by [<A HREF="html.html#Warren82">27</A>],
eliminates the metavariables by wrapping them in a <TT>call/1</TT> goal.
E.g., the rule <TT>and(X,Y):-X, Y</TT> is transformed into <TT>
and(X,Y) :- call(X), call(Y).</TT>
<P>
The transformation of [<A HREF="html.html#Tarau90PLILP">15</A>]
(<EM>binarization</EM>) adds continuations
as  extra   arguments  of   atoms  in a way that  preserves
also first argument indexing.
<P>
Let   P be  a definite  program  and <i>Cont</i>  a  new
variable. Let  <i>T</i> and  <IMG WIDTH=115 HEIGHT=24 ALIGN=MIDDLE ALT="tex2html_wrap_inline898" SRC="img44.gif"  >  be  two 
expressions.<A NAME="tex2html6" HREF="#267"><IMG ALIGN=BOTTOM ALT="gif" SRC="icons//foot_motif.gif" width="15" height="15"></A> We  denote by
 <IMG WIDTH=54 HEIGHT=24 ALIGN=MIDDLE ALT="tex2html_wrap_inline900" SRC="img45.gif"  >  the expression  <IMG WIDTH=101 HEIGHT=24 ALIGN=MIDDLE ALT="tex2html_wrap_inline902" SRC="img46.gif"  > . 
Starting with the clause
<P>
<tex2html_verb_mark><tex2html_verb_mark>   <IMG WIDTH=135 HEIGHT=24 ALIGN=MIDDLE ALT="tex2html_wrap_inline904" SRC="img47.gif"  > 
<P>
we construct the clause
<P>
<tex2html_verb_mark><tex2html_verb_mark>   <IMG WIDTH=313 HEIGHT=24 ALIGN=MIDDLE ALT="tex2html_wrap_inline906" SRC="img48.gif"  > 
<P>
The set  <IMG WIDTH=16 HEIGHT=11 ALIGN=BOTTOM ALT="tex2html_wrap_inline908" SRC="img49.gif"  >  of all clauses <tex2html_verb_mark><tex2html_verb_mark> obtained from the clauses of P is called
the binarization of P.
<P>
The following example shows the result of this
transformation on the well-known `naive reverse' program:
<P>
<PRE>   app([],Ys,Ys,Cont):-true(Cont).
   app([A|Xs],Ys,[A|Zs],Cont):-app(Xs,Ys,Zs,Cont).
                                  
   nrev([],[],Cont):-true(Cont).
   nrev([X|Xs],Zs,Cont):-nrev(Xs,Ys,app(Ys,[X],Zs,Cont)).
</PRE>
<P>
These transformations preserve a 
strong operational equivalence with the
original program with respect to the LD resolution rule, which
is <EM>reified</EM> in the syntactical structure of the
resulting program, i.e. each resolution step
of an LD derivation on a definite program <i>P</i>
can be mapped to an SLD-resolution step of the binarized program  <IMG WIDTH=16 HEIGHT=11 ALIGN=BOTTOM ALT="tex2html_wrap_inline912" SRC="img50.gif"  > ,
in the sense that if G is an atomic goal and  <IMG WIDTH=110 HEIGHT=25 ALIGN=MIDDLE ALT="tex2html_wrap_inline914" SRC="img51.gif"  > , 
then computed answers obtained
querying P with G are the same as those obtained by querying P' with G'.
<P>
Clearly, continuations become explicit in the binary version of the program.
We have devised a technique to access and manipulate them in an intuitive
way, by modifying BinProlog's binarization preprocessor.
Basically, the clauses constructed with <TT>::-</TT> instead of <TT>:-</TT>
are considered as being already in binary form, and not subject
therefore to further binarization. By explicitly accessing
their arguments, a programmer is able to access and modify the
current continuation as a `first order object'.
Note however that code <EM>referring</EM> to the continuation
is also <EM>part</EM> of it, so that some care should be taken in
manipulating the circular term representing the continuation
from `inside'.
<P>
<H1><A NAME="SECTION00060000000000000000">Mobile threads: Take the Future and Run</A></H1>
 <A NAME="mobthreads">&#160;</A>
<P>
As continuations (describing <EM>future</EM> computations
to be performed at a given point) 
are first order objects in BinProlog, 
it is easy to extract from them a conjunction of goals
representing 
<EM>future</EM> computations intended to be performed at
another site,
send it over the network and resume working on it
at that site.
The natural unit of mobility is a <EM>thread</EM>
moving to a server executing multiple 
local and remotely originated threads.
Threads communicate with their local and remote
counterparts, listening on ports
through the Linda protocol, as described in [<A HREF="html.html#dbt95a">7</A>].
<P>
<H2><A NAME="SECTION00061000000000000000">Capturing continuations</A></H2>
 <A NAME="capt">&#160;</A>
<P>
Before moving to another site the current continuation
needs to be captured in a data structure (see Appendix I).
For flexibility, a wrapper <TT>capture_cont_for/1</TT>
is used first to
restrict the scope of the continuation to
a (deterministic) toplevel <TT>Goal</TT>. This avoids taking
irrelevant parts of the continuation (like prompting the user
for the next query) to the remote site inadvertently.
<P>
A unique logical variable is used through a linear
assumption <TT>cont_marker(End)</TT> to mark the end
of the scope of the continuation with <TT>end_cont(End)</TT>.
<P>
From inside the continuation, <TT>call_with_cont/1</TT> is used to
extract the relevant segment of the continuation.  Towards
this end, <TT>consume_cont(Closure,Marker)</TT> extracts a conjunction of
goals from the current continuation until Marker is reached, and then it
applies <TT>Closure</TT> to this conjunction (calls it with the
conjunction passed to <TT>Closure</TT> as an argument).
<P>
Extracting the continuation itself
is easy, by using BinProlog's ability to
accept user defined binarized clauses
(introduced with ::- instead of :-),
accessing the continuation as a `first order' object:
<P>
<PRE>  get_cont(Cont,Cont)::-true(Cont).
</PRE>
<P>
<H2><A NAME="SECTION00062000000000000000">The Continuation Moving Protocol</A></H2>
 <A NAME="contmoving">&#160;</A>
<P>
Our continuation moving protocol can be described easily in terms
of synchronized <EM>source side</EM><A NAME="tex2html7" HREF="#403"><IMG ALIGN=BOTTOM ALT="gif" SRC="icons//foot_motif.gif" width="15" height="15"></A>, 
and <EM>target side</EM> operations.
<P>
<H4><A NAME="SECTION00062010000000000000">Source side operations</A></H4>
<P>
<UL><LI> wrap a Goal
with a unique terminator marking the end of the continuation to be
captured, and call it with the current continuation available
to it through a linearly assumed fact<A NAME="tex2html8" HREF="#304"><IMG ALIGN=BOTTOM ALT="gif" SRC="icons//foot_motif.gif" width="15" height="15"></A>
<P>
<LI> reserve a free port P for the future code server
<LI> schedule on the target server a sequence of actions 
 which will lead to resuming the execution from right after the
 <TT>move_thread</TT> operation (see target
side operations), return and become a code server allowing the mobile
thread to fetch required predicates one a time
</UL><H4><A NAME="SECTION00062020000000000000">Target side operations</A></H4>
 are scheduled as a sequence of goals
extracted from the current continuation at the <EM>source side </EM>, and received
over the network together with a small set of synchronization commands:
<P>
<UL><LI> schedule as delayed task a sequence of goals received from the
source side and return
<LI> wait until the <EM>source side</EM> is in server mode
<LI> set up the back links to the source side as assumptions
<LI> execute the delayed operations representing the moved continuation
<LI> fetch code from the source side as needed for execution of the goals
of the moved continuations and their subcalls 
<LI> shut down the code server on the source side
</UL>
<P>
Communication between the base and the target side
is done with <EM>remote predicate calls</EM>
protected with <EM>dynamically generated passwords</EM>
shared between the two sides before the migratory
components ``takes off''.
<P>
Initially the target side waits in server mode. Once the continuation
is received on the target side, the source side switches in server mode
ready to execute code fetching and persistent database
update requests from its mobile counterpart on the target side.
<P>
<P><A NAME="454">&#160;</A><A NAME="mob">&#160;</A> <IMG WIDTH=286 HEIGHT=179 ALIGN=BOTTOM ALT="figure446" SRC="img52.gif"  > <BR>
<STRONG> 4:</STRONG> Launching a mobile thread from its base<BR>
<P>
<P>
Fig. <A HREF="html.html#mob">4</A> shows the connections between a mobile thread
and its base.
<P>
Note that our continuation moving protocol
expresses <EM>computation mobility</EM> in terms of 
``client-server role alternation'', i.e. by specifying
which end plays which of the roles at a given time.
In principle, with some added complexity, our target-side
<TT>remote_call</TT> operation can be replaced with
equivalent <EM>servant</EM>-based target side code
(see subsection <A HREF="html.html#servant">2.1</A>) if
security restrictions
or unreachability of the target through firewalls
gets in the way.
<P>
As our networking infrastructure, our <EM>mobile threads</EM> are 
platform independent. As Java, BinProlog is a platform
independent emulator based language.
As a consequence, a thread can start on a Unix machine and
move transparently to a Windows NT system and back.
Binaries for
various Unix and Windows platforms are freely available at http://clement.info.umoncton.ca/BinProlog. For faster, platform specific
execution, BinProlog provides compilation to C of static code using
an original partial translation technique described in [<A HREF="html.html#tdb95rev">24</A>].
<P>
<H2><A NAME="SECTION00063000000000000000">An Example</A></H2>
<P>
Networking code expressed in terms of mobile threads tends
to be very compact. The following (self-explanatory) example
illustrates both lazy code fetching and thread movement.
<P>
<PRE>% assumes a server has been started on the same machine with:
%
% ?-port(9300)=&gt;run_unrestricted_server.
%
% Program to be fetched over the network 
% and run on target server
%
a(1).
a(2).
b(X):-a(X).
work_there:-b(X),write('X'=X),nl,fail.

% main code sending a moving thread to server
go:-
  % port where the target server runs
  port(9300)=&gt;
    wrap_thread((     % wraps up code subject to movement
      write(here),nl, % action on `base'
      move_thread,    % actual thread movement
      work_there      % action on target
  )), 
  % code to be executed when `back'
  write(back),nl.
% end of program

% Interaction on TARGET
?-port(9300)=&gt;run_unrestricted_server.
.....
X = 1
X = 2

% Interaction on BASE
?-go.
here
running_server(port(9390),password(pw_5473)) % sets up base server
consulting(../progs/tmob.pl) % sets up code cache
consulted(../progs/tmob.pl)  % by consulting into a local database
time(consulting = 30,quick_compiling = 0,static_space = 0)
server_done(port(9390),password(pw_5473)) % password protected stop
back                                      % message back home
yes
</PRE>
<P>
Note that when the base turns into a server, it offers its
<EM>own code</EM> for remote use by the moved thread - a kind of
virtual ``on demand'' process cloning operation, one step
at a time. As the server actually acts as a code cache,
multiple moving threads can benefit from this operation.
Note also that only predicates needed for the migratory
segment of the continuation are fetched. This ensures
that migratory code is kept lightweight for most mobile
applications.
<P>
<H1><A NAME="SECTION00070000000000000000">Mobile threads - are they needed?</A></H1>
<P>
Advanced <EM>mobile object</EM> and <EM>mobile agents</EM> agent systems
when built on top of Java's impressive dynamic class loading and
its new reflection and remote method invocation classes
like IBM Japan's Aglets or General Magic's Odyssey
provide comprehensive mobility of code and data.
Moreover, data is encapsulated as state of objects.
This property allows protecting sensitive components of it
more easily. Distributed Oz 2 provides fully transparent
movement of objects over the network, giving the illusion
that the same program runs on all the computers.
<P>
So why do we need the apparently more powerful
concept of mobile ``live code'' i.e. mobile execution state?
<P>
<H2><A NAME="SECTION00071000000000000000">The ``pros'' for computation mobility: 
simplicity and learnability</A></H2>
<P>
Our answer to this question is that live mobile code is needed because
is still <EM>semantically simpler</EM> than 
mobile object schemes. Basically, all that a programmer
needs to know is that his or her program has moved to
a new site and it is executing there. A unique (in our case
<TT>move_thread</TT>) primitive, with an
intuitive semantics,  needs to be learned.
When judging about how appropriate a language feature is,
we think that the way it looks to the end user is among the
most important ones. For this reason, mobile threads are
competitive with sophisticated <EM>object mobility</EM> constructs
on ``end-user ergonomy'' grounds,
while being fairly simple to implement, as we have shown,
in languages in which continuations can be easily
represented as data structures.
<P>
<H2><A NAME="SECTION00072000000000000000">Emulating computation mobility through control mobility</A></H2>
 <A NAME="mobemu">&#160;</A>
<P>
As shown in [<A HREF="html.html#TDB97">18</A>],
part of the functionality of <EM>mobile computations</EM> can be emulated
in terms of remote predicate calls combined with remote
code fetching. 
An implicit <EM>virtual place</EM> (host+port) can be set as the target
of the remote calls.
Then, it is enough to send the top-level goal
to the remote side and have it fetch the code as needed from
a server at the site from where the code originates.
<P>
Note however that this is less efficient in terms of network
transactions and less reliable than
sending the full continuation at once as with
our <EM>mobile threads</EM>.
<P>
Overall, our belief is that availability of 
<EM>computation mobility</EM> can help both with
simplifying programming
and with making  distributed applications
more efficient and fault tolerant.
<P>
<H1><A NAME="SECTION00080000000000000000">Mobile Agents</A></H1>
 <A NAME="mobags">&#160;</A>
<P>
<EM>Mobile agents</EM> can be seen as a collection
of synchronized <EM>mobile threads</EM> sharing common 
state [<A HREF="html.html#TD96coord">16</A>].
We have first implemented them by using an emulation of
<EM>computation mobility</EM> in terms of <EM>control mobility</EM>
as described in subsection <A HREF="html.html#mobemu">7.2</A>.
<P>
Mobile agents are implemented by iterating <EM>thread mobility</EM> over
a set of servers<A NAME="tex2html10" HREF="#351"><IMG ALIGN=BOTTOM ALT="gif" SRC="icons//foot_motif.gif" width="15" height="15"></A> known to a given master server.
An efficient pyramidal deployment strategy can be used
to efficiently implement, for instance,
<EM>push technology</EM> through mobile
agents. Inter-agent communication can be achieved either by rendez-vous
of two mobile threads at a given site, by communicating through
a local Prolog database, or through the base server known to
all the deployed agents.
Communication with the base server
is easily achieved through remote predicate calls with
<TT>remote_run</TT>.
Basic security of mobile agents is achieved with 
randomly generated passwords,
required for <TT>remote_run</TT> operations, and
by running them on a restricted BinProlog machine,
without user-level file write and
external process spawn operations.
<P>
Among the applications of mobile agents
easy to express in our framework:
<P>
<UL><LI> enhancing the Web with virtual places
<LI> avatar scripting in virtual worlds
<LI> collecting data from very large databases distributed
over the network through local interrogation
<LI> network monitoring
<LI> remote on-site assistance
<LI> electronic markets
<LI> knowledge discovery/data mining
<LI> tele-teaching
</UL><H1><A NAME="SECTION00090000000000000000">Related work</A></H1>
 <A NAME="rel">&#160;</A>
<P>
A very large number of research projects
have recently started on mobile computations/mobile agent programming.
Among the pioneers, Kahn and Cerf's Knowbots [<A HREF="html.html#knowbots">10</A>]
Among the most promising recent developments,
Luca Cardelli's Oblique project at  Digital and
mobile agent applications [<A HREF="html.html#migratory">1</A>]
and IBM Japan's aglets [<A HREF="html.html#aglets">8</A>].
We share their emphasis on going beyond <EM>code mobility</EM>
and <EM>control mobility</EM> as present in Java and
its RMI, for instance,
towards <EM>computation mobility</EM>.
Mobile code technologies are pioneered by General Magic's
Telescript (see [<A HREF="html.html#odissey">9</A>] for their last Java based 
<EM>mobile agent</EM> product).
Another mobility framework, sharing some of our objectives
towards transparent high level distributed programming
is built on top of Distributed Oz [<A HREF="html.html#DOZmobility">25</A>, <A HREF="html.html#DOZmobs">26</A>],
a multi-paradigm language, also including a logic programming
component.
Although thread mobility is not implemented in Distributed Oz 2,
some of this functionality can be emulated in terms of 
network transparent mobile objects.
Achieving the illusion of a unique application transparently
running on multiple sites makes implementing shared
multi-user applications particularly easy.
We can achieve similar results by implementing mobile agents (e.g.
avatars) as mobile threads with parts of the shared world <EM>visible</EM>
to an agent represented as dynamic facts, lazily replicated through our
lazy code fetching scheme when the agent moves.
Both Distributed Oz 2 and our BinProlog based infrastructure
need a full language processor
(Oz 2 or BinProlog) to be deployed at each node.
However, assuming that a Java processor is already installed,
our framework's Java client (see [<A HREF="html.html#TDB97">18</A>, <A HREF="html.html#TDBwetice97">17</A>, <A HREF="html.html#TDBwww97">19</A>])
allows this functionality to be available through
applets attached to a server side BinProlog thread. 
A calculus of <EM>mobility</EM> dealing with containers,
called <EM>ambients</EM>, is described in [<A HREF="html.html#cardelli97ambients">2</A>].
The calculus covers at very high level of generality movement
and permissions to move from one ambient to another and
show how fundamental computational mechanisms like Turing machines
as well as process calculi can be expressed within the the formalism.
Our <EM>coordination logic</EM> of
[<A HREF="html.html#TD96coord">16</A>]
describes surprisingly similar ideas,
based on programming mobile avatars
in shared virtual worlds.
Two classes of containers, <EM>clonable</EM> and <EM>unique</EM>
regulate creation of new instances (clones) and
non-copiable (unique) entities (like electronic money),
as well as their movement.
<P>
<H1><A NAME="SECTION000100000000000000000">Conclusion</A></H1>
 <A NAME="conc">&#160;</A>
<P>
We have described how mobile threads are implemented by capturing 
first order continuations in a data structure sent over the network.
Supported by <EM>lazy code fetching</EM> and 
<EM>dynamic recompilation</EM>,
they have been shown to be
an effective framework for
implementing mobile agents.
<P>
The techniques presented here are not (Bin)Prolog specific.
The most obvious porting target of our design is to functional
languages featuring first order continuations and threads.
Another porting target is Java and similar OO languages
having threads, reflection classes and 
remote method invocation.
Future work will focus on intelligent mobile agents integrating
knowledge and controlled natural language processing abilities,
following our previous work described in [<A HREF="html.html#DFRT96">5</A>, <A HREF="html.html#RDT97">13</A>, <A HREF="html.html#TDRB97chi">21</A>].
<P>
<H2><A NAME="SECTION000101000000000000000">Acknowledgment</A></H2>
<P>
We thank for support from NSERC (grants OGP0107411 and 611024), and from the
FESR of the Universit&#233; de Moncton.
<P>
<P><A NAME="SECTIONREF"><H2>References</H2></A><P>
<DL COMPACT>
<DT><A NAME="migratory"><STRONG>1</STRONG></A><DD>
K. A. Bharat and L. Cardelli.
Migratory applications.
In <EM>Proceedings of the 8th Annual ACM Symposium on User
  Interface Software and Technology</EM>, Nov. 1995.
<P>
  http://gatekeeper.dec.com/pub/DEC/SRC/research-reports/abstracts/src-rr-138.html.
<P>
<DT><A NAME="cardelli97ambients"><STRONG>2</STRONG></A><DD>
L. Cardelli.
Mobile ambients.
Technical report, Digital, 1997.
<P>
  http://www.research.digital.com/SRC/personal/Luca_Cardelli/Papers.html.
<P>
<DT><A NAME="cardelli97mobile"><STRONG>3</STRONG></A><DD>
L. Cardelli.
Mobile Computation.
In J. Vitek and C. Tschudin, editors, <EM>Mobile Object Systems
  - Towards the Programmable Internet</EM>, pages 3-6. Springer-Verlag,
  LNCS 1228, 1997.
<P>
<DT><A NAME="linda89"><STRONG>4</STRONG></A><DD>
N. Carriero and D. Gelernter.
Linda in context.
<EM>CACM</EM>, 32(4):444-458, 1989.
<P>
<DT><A NAME="DFRT96"><STRONG>5</STRONG></A><DD>
V. Dahl, A. Fall, S. Rochefort, and P. Tarau.
A Hypothetical Reasoning Framework for NL Processing.
In <EM>Proc. 8th IEEE International Conference on Tools with
  Artificial Intelligence</EM>, Toulouse, France, November 1996.
<P>
<DT><A NAME="DT97AGNL"><STRONG>6</STRONG></A><DD>
V. Dahl, P. Tarau, and R. Li.
Assumption Grammars for Processing Natural Language.
In L. Naish, editor, <EM>Proceedings of the Fourteenth International
  Conference on Logic Programming</EM>, pages 256-270, MIT press, 1997.
<P>
<DT><A NAME="dbt95a"><STRONG>7</STRONG></A><DD>
K. De Bosschere and P. Tarau.
Blackboard-based Extensions in Prolog.
<EM>Software -- Practice and Experience</EM>, 26(1):49-69, Jan. 1996.
<P>
<DT><A NAME="aglets"><STRONG>8</STRONG></A><DD>
IBM.
Aglets.
http://www.trl.ibm.co.jp/aglets.
<P>
<DT><A NAME="odissey"><STRONG>9</STRONG></A><DD>
G. M. Inc.
Odissey.
1997.
available at http://www.genmagic.com/agents.
<P>
<DT><A NAME="knowbots"><STRONG>10</STRONG></A><DD>
R. E. Kahn and V. G. Cerf.
The digital library project, volume i: The world of knowbots.
1988.
Unpublished manuscript, Corporation for National Research
  Initiatives, Reston, Va., Mar.
<P>
<DT><A NAME="Miller89Lex"><STRONG>11</STRONG></A><DD>
D. A. Miller.
Lexical scoping as universal quantification.
In G. Levi and M. Martelli, editors, <EM>Proceedings of the Sixth
  International Conference on Logic Programming</EM>, pages 268-283, Cambridge,
  Massachusetts London, England, 1989. MIT Press.
<P>
<DT><A NAME="mycroftpoli"><STRONG>12</STRONG></A><DD>
A. Mycroft and R. A. O'Keefe.
A polimorphic type system for prolog.
<EM>Artificial Intelligence</EM>, (23):295-307, 1984.
<P>
<DT><A NAME="RDT97"><STRONG>13</STRONG></A><DD>
S. Rochefort, V. Dahl, and P. Tarau.
Controlling Virtual Worlds through Extensible Natural
  Language.
In <EM>AAAI Symposium on NLP for the WWW</EM>, Stanford University, CA,
  1997.
<P>
<DT><A NAME="Tarau97BinProlog"><STRONG>14</STRONG></A><DD>
P. Tarau.
BinProlog 5.75 User Guide.
Technical Report 97-1, D&#233;partement d'Informatique, Universit&#233;
  de Moncton, Apr. 1997.
Available from <EM>http://clement.info.umoncton.ca/BinProlog</EM>.
<P>
<DT><A NAME="Tarau90PLILP"><STRONG>15</STRONG></A><DD>
P. Tarau and M. Boyer.
Elementary Logic Programs.
In P. Deransart and J. Maluszynski, editors, <EM>Proceedings of
  Programming Language Implementation and Logic Programming</EM>, number 456 in
  Lecture Notes in Computer Science, pages 159-173. Springer, Aug. 1990.
<P>
<DT><A NAME="TD96coord"><STRONG>16</STRONG></A><DD>
P. Tarau and V. Dahl.
A Coordination Logic for Agent Programming in Virtual
  Worlds.
In W. Conen and G. Neumann, editors, <EM>Proceedings of Asian'96
  Post-Conference Workshop on Coordination Technology for Collaborative
  Applications</EM>, Singapore, Dec. 1996.
to appear in LNCS, Springer.
<P>
<DT><A NAME="TDBwetice97"><STRONG>17</STRONG></A><DD>
P. Tarau, V. Dahl, and K. De Bosschere.
A Logic Programming Infrastructure for Remote Execution,
  Mobile Code and Agents.
In <EM>Proceedings of IEEE WETICE'97</EM>, Boston, MA, June 1997.
<P>
<DT><A NAME="TDB97"><STRONG>18</STRONG></A><DD>
P. Tarau, V. Dahl, and K. De Bosschere.
Logic Programming Tools for Remote Execution, Mobile
  Code and Agents.
In <EM>Proceedings of ICLP'97 Workshop on Logic Programming
  and Multi Agent Systems</EM>, Leuven, Belgium, July 1997.
<P>
<DT><A NAME="TDBwww97"><STRONG>19</STRONG></A><DD>
P. Tarau, V. Dahl, and K. De Bosschere.
Remite execution, mobile code and agents in binprolog.
In <EM>Electronic Proceedings of WWW6 Logic Programming
  Workshop, http://www.cs.vu.nl/ eliens/WWW6/papers.html</EM>, Santa Clara,
  California, Mar. 1997.
<P>
<DT><A NAME="TDFasian96"><STRONG>20</STRONG></A><DD>
P. Tarau, V. Dahl, and A. Fall.
Backtrackable State with Linear Affine Implication and
  Assumption Grammars.
In J. Jaffar and R. H. Yap, editors, <EM>Concurrency and
  Parallelism, Programming, Networking, and Security</EM>, Lecture Notes in
  Computer Science 1179, pages 53-64, Singapore, Dec. 1996. Springer.
<P>
<DT><A NAME="TDRB97chi"><STRONG>21</STRONG></A><DD>
P. Tarau, V. Dahl, S. Rochefort, and K. De Bosschere.
LogiMOO: a Multi-User Virtual World with Agents and
  Natural Language Programming.
In S. Pemberton, editor, <EM>Proceedings of CHI'97</EM>, pages 323-324,
  Mar. 1997.
ACM ISBN 0-8979-926-2.
<P>
<DT><A NAME="pt93b"><STRONG>22</STRONG></A><DD>
P. Tarau and K. De Bosschere.
Memoing with Abstract Answers and Delphi Lemmas.
In Y. Deville, editor, <EM>Logic Program Synthesis and
  Transformation</EM>, Springer-Verlag, Workshops in Computing, pages 196-209,
  Louvain-la-Neuve, July 1993.
<P>
<DT><A NAME="lpnet96virtual"><STRONG>23</STRONG></A><DD>
P. Tarau and K. De Bosschere.
Virtual World Brokerage with BinProlog and Netscape.
In P. Tarau, A. Davison, K. De Bosschere, and M. Hermenegildo,
  editors, <EM>Proceedings of the 1st Workshop on Logic Programming Tools for
  INTERNET Applications</EM>, JICSLP'96, Bonn, Sept. 1996.
http://clement.info.umoncton.ca/ lpnet.
<P>
<DT><A NAME="tdb95rev"><STRONG>24</STRONG></A><DD>
P. Tarau, K. De Bosschere, and B. Demoen.
Partial Translation: Towards a Portable and Efficient Prolog
  Implementation Technology.
<EM>Journal of Logic Programming</EM>, 29(1-3):65-83, Nov. 1996.
<P>
<DT><A NAME="DOZmobility"><STRONG>25</STRONG></A><DD>
P. Van Roy, S. Haridi, and P. Brand.
Using mobility to make transparent distribution practical.
1997.
manuscript.
<P>
<DT><A NAME="DOZmobs"><STRONG>26</STRONG></A><DD>
P. Van Roy, S. Haridi, P. Brand, G. Smolka, M. Mehl, and R. Scheidhouer.
Mobile Objects in Distributed Oz.
<EM>ACM TOPLAS</EM>, 1997.
to appear.
<P>
<DT><A NAME="Warren82"><STRONG>27</STRONG></A><DD>
D. H. D. Warren.
Higher-order extensions to Prolog - are they needed?
In D. Michie, J. Hayes, and Y. H. Pao, editors, <EM>Machine
  Intelligence 10</EM>. Ellis Horwood, 1981.
</DL>
<P>
<H1><A NAME="SECTION000120000000000000000">Appendix I: Capturing First Order Continuations in BinProlog</A></H1>
<P>
<PRE>% calls Goal with current continuation available to its inner calls
capture_cont_for(Goal):-
  assumeal(cont_marker(End)),
    Goal,
  end_cont(End).

% passes Closure to be called on accumulated continuation
call_with_cont(Closure):-
  assumed(cont_marker(End)),
  consume_cont(Closure,End).
  
% gathers in conjunction goals from the current continuation
% until Marker is reached when it calls Closure on it
consume_cont(Closure,Marker):-
  get_cont(Cont),
  consume_cont1(Marker,(_,_,_,Cs),Cont,NewCont), % first _
  call(Closure,Cs),                              % second _
  % sets current continuation to leftover NewCont    
  call_cont(NewCont).                            % third _

% gathers goals in Gs until Marker is hit in continuation Cont
% when leftover LastCont continuation (stripped of Gs) is returned
consume_cont1(Marker,Gs,Cont,LastCont):-
   strip_cont(Cont,Goal,NextCont),
   ( NextCont==true-&gt; !,errmes(in_consume_cont,expected_marker(Marker))
   ; arg(1,NextCont,X),Marker==X-&gt;
     Gs=Goal,arg(2,NextCont,LastCont)
   ; Gs=(Goal,OtherGs),
     consume_cont1(Marker,OtherGs,NextCont,LastCont)
   ).

% this `binarized clause' gets the current continuation
get_cont(Cont,Cont)::-true(Cont).

% sets calls NewCont as continuation to be called next
call_cont(NewCont,_) ::- true(NewCont).
</PRE>
<P>
<H1><A NAME="SECTION000130000000000000000">Appendix II: Thread Mobility in BinProlog</A></H1>
<P>
<PRE>% wraps continuation of current thread to be taken
% by inner move_thread goal to be executed remotely 
wrap_thread(Goal):-
  capture_cont_for(Goal).

% picks up wrapped continuation,
% jumps to default remote site and runs it there
move_thread:-
  call_with_cont(move_with_cont).
  
% moves to remote site goals Gs in current continuation
move_with_cont(Gs):-
  % gets info about this host
  detect_host(BackHost),
  get_free_port(BackPort),
  default_password(BackPasswd),
  default_code(BackCode),
  % runs delayed remote command (assumes is with +/1)
  remote_run(
     +todo(
       host(BackHost)=&gt;&gt;port(BackPort)=&gt;&gt;code(BackCode)=&gt;&gt;(
         sleep(5), % waits until server on BackPort is up
         % runs foals Gs picked up from current continuation 
         (Gs-&gt;true;true), % ignores failure
         % stops server back on site of origin
         stop_server(BackPasswd)
       )
     )
  ),
  % becomes data and code server for mobile code until is
  % stopped by mobile code possessing password
  server_port(BackPort)=&gt;&gt;run_unrestricted_server.
</PRE>
<P>
<DL> <DT><A NAME="104">...continuations</A><DD>I.e. continuations
accessible as an ordinary data structure - a Prolog term in this case.
<PRE>
</PRE><DT><A NAME="175">...MOO</A><DD>Multi User Domains (MUDs), Object Oriented - venerable but
still well doing ancestors of more recent multi-user Virtual Worlds,
which are usually 3D-animation (VRML) based
<PRE>
</PRE><DT><A NAME="267">...expressions.</A><DD>Atom or term.
<PRE>
</PRE><DT><A NAME="403">...side</A><DD>which will be
also shortly called the <EM>base</EM> of the mobile thread
<PRE>
</PRE><DT><A NAME="304">...fact</A><DD>BinProlog's linear assumptions
 are backtrackable additions to the database, usable at most once.
<P>
<PRE>
</PRE><DT><A NAME="351">...servers</A><DD>possibly filtered down
to a relevant subset using 
a `channel'-like pattern
<PRE>
</PRE> </DL>
<BR> <HR>
<P><ADDRESS>
<I>Paul Tarau <BR>
Tue Sep  2 21:37:18 ADT 1997</I>
</ADDRESS>
</BODY>
</HTML>
